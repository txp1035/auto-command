(function(){var r={423:function(r,t,n){
/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */
if(!globalThis.DOMException){try{const{MessageChannel:r}=n(267),t=(new r).port1,a=new ArrayBuffer;t.postMessage(a,[a,a])}catch(r){r.constructor.name==="DOMException"&&(globalThis.DOMException=r.constructor)}}r.exports=globalThis.DOMException},991:function(r,t){(function(r,n){true?n(t):0})(this,(function(r){"use strict";const t=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?Symbol:r=>`Symbol(${r})`;function noop(){return undefined}function getGlobals(){if(typeof self!=="undefined"){return self}else if(typeof window!=="undefined"){return window}else if(typeof global!=="undefined"){return global}return undefined}const n=getGlobals();function typeIsObject(r){return typeof r==="object"&&r!==null||typeof r==="function"}const a=noop;const o=Promise;const i=Promise.prototype.then;const l=Promise.resolve.bind(o);const s=Promise.reject.bind(o);function newPromise(r){return new o(r)}function promiseResolvedWith(r){return l(r)}function promiseRejectedWith(r){return s(r)}function PerformPromiseThen(r,t,n){return i.call(r,t,n)}function uponPromise(r,t,n){PerformPromiseThen(PerformPromiseThen(r,t,n),undefined,a)}function uponFulfillment(r,t){uponPromise(r,t)}function uponRejection(r,t){uponPromise(r,undefined,t)}function transformPromiseWith(r,t,n){return PerformPromiseThen(r,t,n)}function setPromiseIsHandledToTrue(r){PerformPromiseThen(r,undefined,a)}const u=(()=>{const r=n&&n.queueMicrotask;if(typeof r==="function"){return r}const t=promiseResolvedWith(undefined);return r=>PerformPromiseThen(t,r)})();function reflectCall(r,t,n){if(typeof r!=="function"){throw new TypeError("Argument is not a function")}return Function.prototype.apply.call(r,t,n)}function promiseCall(r,t,n){try{return promiseResolvedWith(reflectCall(r,t,n))}catch(r){return promiseRejectedWith(r)}}const d=16384;class SimpleQueue{constructor(){this._cursor=0;this._size=0;this._front={_elements:[],_next:undefined};this._back=this._front;this._cursor=0;this._size=0}get length(){return this._size}push(r){const t=this._back;let n=t;if(t._elements.length===d-1){n={_elements:[],_next:undefined}}t._elements.push(r);if(n!==t){this._back=n;t._next=n}++this._size}shift(){const r=this._front;let t=r;const n=this._cursor;let a=n+1;const o=r._elements;const i=o[n];if(a===d){t=r._next;a=0}--this._size;this._cursor=a;if(r!==t){this._front=t}o[n]=undefined;return i}forEach(r){let t=this._cursor;let n=this._front;let a=n._elements;while(t!==a.length||n._next!==undefined){if(t===a.length){n=n._next;a=n._elements;t=0;if(a.length===0){break}}r(a[t]);++t}}peek(){const r=this._front;const t=this._cursor;return r._elements[t]}}function ReadableStreamReaderGenericInitialize(r,t){r._ownerReadableStream=t;t._reader=r;if(t._state==="readable"){defaultReaderClosedPromiseInitialize(r)}else if(t._state==="closed"){defaultReaderClosedPromiseInitializeAsResolved(r)}else{defaultReaderClosedPromiseInitializeAsRejected(r,t._storedError)}}function ReadableStreamReaderGenericCancel(r,t){const n=r._ownerReadableStream;return ReadableStreamCancel(n,t)}function ReadableStreamReaderGenericRelease(r){if(r._ownerReadableStream._state==="readable"){defaultReaderClosedPromiseReject(r,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}else{defaultReaderClosedPromiseResetToRejected(r,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}r._ownerReadableStream._reader=undefined;r._ownerReadableStream=undefined}function readerLockException(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(r){r._closedPromise=newPromise(((t,n)=>{r._closedPromise_resolve=t;r._closedPromise_reject=n}))}function defaultReaderClosedPromiseInitializeAsRejected(r,t){defaultReaderClosedPromiseInitialize(r);defaultReaderClosedPromiseReject(r,t)}function defaultReaderClosedPromiseInitializeAsResolved(r){defaultReaderClosedPromiseInitialize(r);defaultReaderClosedPromiseResolve(r)}function defaultReaderClosedPromiseReject(r,t){if(r._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._closedPromise);r._closedPromise_reject(t);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined}function defaultReaderClosedPromiseResetToRejected(r,t){defaultReaderClosedPromiseInitializeAsRejected(r,t)}function defaultReaderClosedPromiseResolve(r){if(r._closedPromise_resolve===undefined){return}r._closedPromise_resolve(undefined);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined}const c=t("[[AbortSteps]]");const m=t("[[ErrorSteps]]");const b=t("[[CancelSteps]]");const h=t("[[PullSteps]]");const p=Number.isFinite||function(r){return typeof r==="number"&&isFinite(r)};const S=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function isDictionary(r){return typeof r==="object"||typeof r==="function"}function assertDictionary(r,t){if(r!==undefined&&!isDictionary(r)){throw new TypeError(`${t} is not an object.`)}}function assertFunction(r,t){if(typeof r!=="function"){throw new TypeError(`${t} is not a function.`)}}function isObject(r){return typeof r==="object"&&r!==null||typeof r==="function"}function assertObject(r,t){if(!isObject(r)){throw new TypeError(`${t} is not an object.`)}}function assertRequiredArgument(r,t,n){if(r===undefined){throw new TypeError(`Parameter ${t} is required in '${n}'.`)}}function assertRequiredField(r,t,n){if(r===undefined){throw new TypeError(`${t} is required in '${n}'.`)}}function convertUnrestrictedDouble(r){return Number(r)}function censorNegativeZero(r){return r===0?0:r}function integerPart(r){return censorNegativeZero(S(r))}function convertUnsignedLongLongWithEnforceRange(r,t){const n=0;const a=Number.MAX_SAFE_INTEGER;let o=Number(r);o=censorNegativeZero(o);if(!p(o)){throw new TypeError(`${t} is not a finite number`)}o=integerPart(o);if(o<n||o>a){throw new TypeError(`${t} is outside the accepted range of ${n} to ${a}, inclusive`)}if(!p(o)||o===0){return 0}return o}function assertReadableStream(r,t){if(!IsReadableStream(r)){throw new TypeError(`${t} is not a ReadableStream.`)}}function AcquireReadableStreamDefaultReader(r){return new ReadableStreamDefaultReader(r)}function ReadableStreamAddReadRequest(r,t){r._reader._readRequests.push(t)}function ReadableStreamFulfillReadRequest(r,t,n){const a=r._reader;const o=a._readRequests.shift();if(n){o._closeSteps()}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadRequests(r){return r._reader._readRequests.length}function ReadableStreamHasDefaultReader(r){const t=r._reader;if(t===undefined){return false}if(!IsReadableStreamDefaultReader(t)){return false}return true}class ReadableStreamDefaultReader{constructor(r){assertRequiredArgument(r,1,"ReadableStreamDefaultReader");assertReadableStream(r,"First parameter");if(IsReadableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}ReadableStreamReaderGenericInitialize(this,r);this._readRequests=new SimpleQueue}get closed(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("closed"))}return this._closedPromise}cancel(r=undefined){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,r)}read(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("read"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let r;let t;const n=newPromise(((n,a)=>{r=n;t=a}));const a={_chunkSteps:t=>r({value:t,done:false}),_closeSteps:()=>r({value:undefined,done:true}),_errorSteps:r=>t(r)};ReadableStreamDefaultReaderRead(this,a);return n}releaseLock(){if(!IsReadableStreamDefaultReader(this)){throw defaultReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultReader.prototype,t.toStringTag,{value:"ReadableStreamDefaultReader",configurable:true})}function IsReadableStreamDefaultReader(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readRequests")){return false}return r instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(r,t){const n=r._ownerReadableStream;n._disturbed=true;if(n._state==="closed"){t._closeSteps()}else if(n._state==="errored"){t._errorSteps(n._storedError)}else{n._readableStreamController[h](t)}}function defaultReaderBrandCheckException(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}const y=Object.getPrototypeOf(Object.getPrototypeOf((async function*(){})).prototype);class ReadableStreamAsyncIteratorImpl{constructor(r,t){this._ongoingPromise=undefined;this._isFinished=false;this._reader=r;this._preventCancel=t}next(){const nextSteps=()=>this._nextSteps();this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps();return this._ongoingPromise}return(r){const returnSteps=()=>this._returnSteps(r);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){if(this._isFinished){return Promise.resolve({value:undefined,done:true})}const r=this._reader;if(r._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("iterate"))}let t;let n;const a=newPromise(((r,a)=>{t=r;n=a}));const o={_chunkSteps:r=>{this._ongoingPromise=undefined;u((()=>t({value:r,done:false})))},_closeSteps:()=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(r);t({value:undefined,done:true})},_errorSteps:t=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(r);n(t)}};ReadableStreamDefaultReaderRead(r,o);return a}_returnSteps(r){if(this._isFinished){return Promise.resolve({value:r,done:true})}this._isFinished=true;const t=this._reader;if(t._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("finish iterating"))}if(!this._preventCancel){const n=ReadableStreamReaderGenericCancel(t,r);ReadableStreamReaderGenericRelease(t);return transformPromiseWith(n,(()=>({value:r,done:true})))}ReadableStreamReaderGenericRelease(t);return promiseResolvedWith({value:r,done:true})}}const R={next(){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))}return this._asyncIteratorImpl.next()},return(r){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}return this._asyncIteratorImpl.return(r)}};if(y!==undefined){Object.setPrototypeOf(R,y)}function AcquireReadableStreamAsyncIterator(r,t){const n=AcquireReadableStreamDefaultReader(r);const a=new ReadableStreamAsyncIteratorImpl(n,t);const o=Object.create(R);o._asyncIteratorImpl=a;return o}function IsReadableStreamAsyncIterator(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl")){return false}try{return r._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(r){return false}}function streamAsyncIteratorBrandCheckException(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}const g=Number.isNaN||function(r){return r!==r};function CreateArrayFromList(r){return r.slice()}function CopyDataBlockBytes(r,t,n,a,o){new Uint8Array(r).set(new Uint8Array(n,a,o),t)}function TransferArrayBuffer(r){return r}function IsDetachedBuffer(r){return false}function ArrayBufferSlice(r,t,n){if(r.slice){return r.slice(t,n)}const a=n-t;const o=new ArrayBuffer(a);CopyDataBlockBytes(o,0,r,t,a);return o}function IsNonNegativeNumber(r){if(typeof r!=="number"){return false}if(g(r)){return false}if(r<0){return false}return true}function CloneAsUint8Array(r){const t=ArrayBufferSlice(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(t)}function DequeueValue(r){const t=r._queue.shift();r._queueTotalSize-=t.size;if(r._queueTotalSize<0){r._queueTotalSize=0}return t.value}function EnqueueValueWithSize(r,t,n){if(!IsNonNegativeNumber(n)||n===Infinity){throw new RangeError("Size must be a finite, non-NaN, non-negative number.")}r._queue.push({value:t,size:n});r._queueTotalSize+=n}function PeekQueueValue(r){const t=r._queue.peek();return t.value}function ResetQueue(r){r._queue=new SimpleQueue;r._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("view")}return this._view}respond(r){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respond")}assertRequiredArgument(r,1,"respond");r=convertUnsignedLongLongWithEnforceRange(r,"First parameter");if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(this._view.buffer));ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,r)}respondWithNewView(r){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respondWithNewView")}assertRequiredArgument(r,1,"respondWithNewView");if(!ArrayBuffer.isView(r)){throw new TypeError("You can only respond with array buffer views")}if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(r.buffer));ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,r)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:true},respondWithNewView:{enumerable:true},view:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBRequest.prototype,t.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:true})}class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("byobRequest")}return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("desiredSize")}return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("close")}if(this._closeRequested){throw new TypeError("The stream has already been closed; do not close it again!")}const r=this._controlledReadableByteStream._state;if(r!=="readable"){throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be closed`)}ReadableByteStreamControllerClose(this)}enqueue(r){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("enqueue")}assertRequiredArgument(r,1,"enqueue");if(!ArrayBuffer.isView(r)){throw new TypeError("chunk must be an array buffer view")}if(r.byteLength===0){throw new TypeError("chunk must have non-zero byteLength")}if(r.buffer.byteLength===0){throw new TypeError(`chunk's buffer must have non-zero byteLength`)}if(this._closeRequested){throw new TypeError("stream is closed or draining")}const t=this._controlledReadableByteStream._state;if(t!=="readable"){throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`)}ReadableByteStreamControllerEnqueue(this,r)}error(r=undefined){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("error")}ReadableByteStreamControllerError(this,r)}[b](r){ReadableByteStreamControllerClearPendingPullIntos(this);ResetQueue(this);const t=this._cancelAlgorithm(r);ReadableByteStreamControllerClearAlgorithms(this);return t}[h](r){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0){const t=this._queue.shift();this._queueTotalSize-=t.byteLength;ReadableByteStreamControllerHandleQueueDrain(this);const n=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);r._chunkSteps(n);return}const n=this._autoAllocateChunkSize;if(n!==undefined){let t;try{t=new ArrayBuffer(n)}catch(t){r._errorSteps(t);return}const a={buffer:t,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(a)}ReadableStreamAddReadRequest(t,r);ReadableByteStreamControllerCallPullIfNeeded(this)}}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},byobRequest:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableByteStreamController.prototype,t.toStringTag,{value:"ReadableByteStreamController",configurable:true})}function IsReadableByteStreamController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")){return false}return r instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")){return false}return r instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(r){const t=ReadableByteStreamControllerShouldCallPull(r);if(!t){return}if(r._pulling){r._pullAgain=true;return}r._pulling=true;const n=r._pullAlgorithm();uponPromise(n,(()=>{r._pulling=false;if(r._pullAgain){r._pullAgain=false;ReadableByteStreamControllerCallPullIfNeeded(r)}}),(t=>{ReadableByteStreamControllerError(r,t)}))}function ReadableByteStreamControllerClearPendingPullIntos(r){ReadableByteStreamControllerInvalidateBYOBRequest(r);r._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(r,t){let n=false;if(r._state==="closed"){n=true}const a=ReadableByteStreamControllerConvertPullIntoDescriptor(t);if(t.readerType==="default"){ReadableStreamFulfillReadRequest(r,a,n)}else{ReadableStreamFulfillReadIntoRequest(r,a,n)}}function ReadableByteStreamControllerConvertPullIntoDescriptor(r){const t=r.bytesFilled;const n=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,t/n)}function ReadableByteStreamControllerEnqueueChunkToQueue(r,t,n,a){r._queue.push({buffer:t,byteOffset:n,byteLength:a});r._queueTotalSize+=a}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t){const n=t.elementSize;const a=t.bytesFilled-t.bytesFilled%n;const o=Math.min(r._queueTotalSize,t.byteLength-t.bytesFilled);const i=t.bytesFilled+o;const l=i-i%n;let s=o;let u=false;if(l>a){s=l-t.bytesFilled;u=true}const d=r._queue;while(s>0){const n=d.peek();const a=Math.min(s,n.byteLength);const o=t.byteOffset+t.bytesFilled;CopyDataBlockBytes(t.buffer,o,n.buffer,n.byteOffset,a);if(n.byteLength===a){d.shift()}else{n.byteOffset+=a;n.byteLength-=a}r._queueTotalSize-=a;ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,a,t);s-=a}return u}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,n){n.bytesFilled+=t}function ReadableByteStreamControllerHandleQueueDrain(r){if(r._queueTotalSize===0&&r._closeRequested){ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamClose(r._controlledReadableByteStream)}else{ReadableByteStreamControllerCallPullIfNeeded(r)}}function ReadableByteStreamControllerInvalidateBYOBRequest(r){if(r._byobRequest===null){return}r._byobRequest._associatedReadableByteStreamController=undefined;r._byobRequest._view=null;r._byobRequest=null}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r){while(r._pendingPullIntos.length>0){if(r._queueTotalSize===0){return}const t=r._pendingPullIntos.peek();if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t)){ReadableByteStreamControllerShiftPendingPullInto(r);ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,t)}}}function ReadableByteStreamControllerPullInto(r,t,n){const a=r._controlledReadableByteStream;let o=1;if(t.constructor!==DataView){o=t.constructor.BYTES_PER_ELEMENT}const i=t.constructor;const l=TransferArrayBuffer(t.buffer);const s={buffer:l,bufferByteLength:l.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:o,viewConstructor:i,readerType:"byob"};if(r._pendingPullIntos.length>0){r._pendingPullIntos.push(s);ReadableStreamAddReadIntoRequest(a,n);return}if(a._state==="closed"){const r=new i(s.buffer,s.byteOffset,0);n._closeSteps(r);return}if(r._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,s)){const t=ReadableByteStreamControllerConvertPullIntoDescriptor(s);ReadableByteStreamControllerHandleQueueDrain(r);n._chunkSteps(t);return}if(r._closeRequested){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(r,t);n._errorSteps(t);return}}r._pendingPullIntos.push(s);ReadableStreamAddReadIntoRequest(a,n);ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerRespondInClosedState(r,t){const n=r._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(n)){while(ReadableStreamGetNumReadIntoRequests(n)>0){const t=ReadableByteStreamControllerShiftPendingPullInto(r);ReadableByteStreamControllerCommitPullIntoDescriptor(n,t)}}}function ReadableByteStreamControllerRespondInReadableState(r,t,n){ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,n);if(n.bytesFilled<n.elementSize){return}ReadableByteStreamControllerShiftPendingPullInto(r);const a=n.bytesFilled%n.elementSize;if(a>0){const t=n.byteOffset+n.bytesFilled;const o=ArrayBufferSlice(n.buffer,t-a,t);ReadableByteStreamControllerEnqueueChunkToQueue(r,o,0,o.byteLength)}n.bytesFilled-=a;ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,n);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)}function ReadableByteStreamControllerRespondInternal(r,t){const n=r._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(r);const a=r._controlledReadableByteStream._state;if(a==="closed"){ReadableByteStreamControllerRespondInClosedState(r)}else{ReadableByteStreamControllerRespondInReadableState(r,t,n)}ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerShiftPendingPullInto(r){const t=r._pendingPullIntos.shift();return t}function ReadableByteStreamControllerShouldCallPull(r){const t=r._controlledReadableByteStream;if(t._state!=="readable"){return false}if(r._closeRequested){return false}if(!r._started){return false}if(ReadableStreamHasDefaultReader(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}if(ReadableStreamHasBYOBReader(t)&&ReadableStreamGetNumReadIntoRequests(t)>0){return true}const n=ReadableByteStreamControllerGetDesiredSize(r);if(n>0){return true}return false}function ReadableByteStreamControllerClearAlgorithms(r){r._pullAlgorithm=undefined;r._cancelAlgorithm=undefined}function ReadableByteStreamControllerClose(r){const t=r._controlledReadableByteStream;if(r._closeRequested||t._state!=="readable"){return}if(r._queueTotalSize>0){r._closeRequested=true;return}if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(t.bytesFilled>0){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(r,t);throw t}}ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamClose(t)}function ReadableByteStreamControllerEnqueue(r,t){const n=r._controlledReadableByteStream;if(r._closeRequested||n._state!=="readable"){return}const a=t.buffer;const o=t.byteOffset;const i=t.byteLength;const l=TransferArrayBuffer(a);if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(IsDetachedBuffer(t.buffer));t.buffer=TransferArrayBuffer(t.buffer)}ReadableByteStreamControllerInvalidateBYOBRequest(r);if(ReadableStreamHasDefaultReader(n)){if(ReadableStreamGetNumReadRequests(n)===0){ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i)}else{if(r._pendingPullIntos.length>0){ReadableByteStreamControllerShiftPendingPullInto(r)}const t=new Uint8Array(l,o,i);ReadableStreamFulfillReadRequest(n,t,false)}}else if(ReadableStreamHasBYOBReader(n)){ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)}else{ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i)}ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerError(r,t){const n=r._controlledReadableByteStream;if(n._state!=="readable"){return}ReadableByteStreamControllerClearPendingPullIntos(r);ResetQueue(r);ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamError(n,t)}function ReadableByteStreamControllerGetBYOBRequest(r){if(r._byobRequest===null&&r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();const n=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled);const a=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(a,r,n);r._byobRequest=a}return r._byobRequest}function ReadableByteStreamControllerGetDesiredSize(r){const t=r._controlledReadableByteStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return r._strategyHWM-r._queueTotalSize}function ReadableByteStreamControllerRespond(r,t){const n=r._pendingPullIntos.peek();const a=r._controlledReadableByteStream._state;if(a==="closed"){if(t!==0){throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}}else{if(t===0){throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream")}if(n.bytesFilled+t>n.byteLength){throw new RangeError("bytesWritten out of range")}}n.buffer=TransferArrayBuffer(n.buffer);ReadableByteStreamControllerRespondInternal(r,t)}function ReadableByteStreamControllerRespondWithNewView(r,t){const n=r._pendingPullIntos.peek();const a=r._controlledReadableByteStream._state;if(a==="closed"){if(t.byteLength!==0){throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}}else{if(t.byteLength===0){throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream")}}if(n.byteOffset+n.bytesFilled!==t.byteOffset){throw new RangeError("The region specified by view does not match byobRequest")}if(n.bufferByteLength!==t.buffer.byteLength){throw new RangeError("The buffer of view has different capacity than byobRequest")}if(n.bytesFilled+t.byteLength>n.byteLength){throw new RangeError("The region specified by view is larger than byobRequest")}const o=t.byteLength;n.buffer=TransferArrayBuffer(t.buffer);ReadableByteStreamControllerRespondInternal(r,o)}function SetUpReadableByteStreamController(r,t,n,a,o,i,l){t._controlledReadableByteStream=r;t._pullAgain=false;t._pulling=false;t._byobRequest=null;t._queue=t._queueTotalSize=undefined;ResetQueue(t);t._closeRequested=false;t._started=false;t._strategyHWM=i;t._pullAlgorithm=a;t._cancelAlgorithm=o;t._autoAllocateChunkSize=l;t._pendingPullIntos=new SimpleQueue;r._readableStreamController=t;const s=n();uponPromise(promiseResolvedWith(s),(()=>{t._started=true;ReadableByteStreamControllerCallPullIfNeeded(t)}),(r=>{ReadableByteStreamControllerError(t,r)}))}function SetUpReadableByteStreamControllerFromUnderlyingSource(r,t,n){const a=Object.create(ReadableByteStreamController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(a)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(a)}if(t.cancel!==undefined){cancelAlgorithm=r=>t.cancel(r)}const o=t.autoAllocateChunkSize;if(o===0){throw new TypeError("autoAllocateChunkSize must be greater than 0")}SetUpReadableByteStreamController(r,a,startAlgorithm,pullAlgorithm,cancelAlgorithm,n,o)}function SetUpReadableStreamBYOBRequest(r,t,n){r._associatedReadableByteStreamController=t;r._view=n}function byobRequestBrandCheckException(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function AcquireReadableStreamBYOBReader(r){return new ReadableStreamBYOBReader(r)}function ReadableStreamAddReadIntoRequest(r,t){r._reader._readIntoRequests.push(t)}function ReadableStreamFulfillReadIntoRequest(r,t,n){const a=r._reader;const o=a._readIntoRequests.shift();if(n){o._closeSteps(t)}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadIntoRequests(r){return r._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(r){const t=r._reader;if(t===undefined){return false}if(!IsReadableStreamBYOBReader(t)){return false}return true}class ReadableStreamBYOBReader{constructor(r){assertRequiredArgument(r,1,"ReadableStreamBYOBReader");assertReadableStream(r,"First parameter");if(IsReadableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}if(!IsReadableByteStreamController(r._readableStreamController)){throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte "+"source")}ReadableStreamReaderGenericInitialize(this,r);this._readIntoRequests=new SimpleQueue}get closed(){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("closed"))}return this._closedPromise}cancel(r=undefined){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,r)}read(r){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("read"))}if(!ArrayBuffer.isView(r)){return promiseRejectedWith(new TypeError("view must be an array buffer view"))}if(r.byteLength===0){return promiseRejectedWith(new TypeError("view must have non-zero byteLength"))}if(r.buffer.byteLength===0){return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`))}if(IsDetachedBuffer(r.buffer));if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let t;let n;const a=newPromise(((r,a)=>{t=r;n=a}));const o={_chunkSteps:r=>t({value:r,done:false}),_closeSteps:r=>t({value:r,done:true}),_errorSteps:r=>n(r)};ReadableStreamBYOBReaderRead(this,r,o);return a}releaseLock(){if(!IsReadableStreamBYOBReader(this)){throw byobReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readIntoRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBReader.prototype,t.toStringTag,{value:"ReadableStreamBYOBReader",configurable:true})}function IsReadableStreamBYOBReader(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")){return false}return r instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(r,t,n){const a=r._ownerReadableStream;a._disturbed=true;if(a._state==="errored"){n._errorSteps(a._storedError)}else{ReadableByteStreamControllerPullInto(a._readableStreamController,t,n)}}function byobReaderBrandCheckException(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(r,t){const{highWaterMark:n}=r;if(n===undefined){return t}if(g(n)||n<0){throw new RangeError("Invalid highWaterMark")}return n}function ExtractSizeAlgorithm(r){const{size:t}=r;if(!t){return()=>1}return t}function convertQueuingStrategy(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.highWaterMark;const a=r===null||r===void 0?void 0:r.size;return{highWaterMark:n===undefined?undefined:convertUnrestrictedDouble(n),size:a===undefined?undefined:convertQueuingStrategySize(a,`${t} has member 'size' that`)}}function convertQueuingStrategySize(r,t){assertFunction(r,t);return t=>convertUnrestrictedDouble(r(t))}function convertUnderlyingSink(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.abort;const a=r===null||r===void 0?void 0:r.close;const o=r===null||r===void 0?void 0:r.start;const i=r===null||r===void 0?void 0:r.type;const l=r===null||r===void 0?void 0:r.write;return{abort:n===undefined?undefined:convertUnderlyingSinkAbortCallback(n,r,`${t} has member 'abort' that`),close:a===undefined?undefined:convertUnderlyingSinkCloseCallback(a,r,`${t} has member 'close' that`),start:o===undefined?undefined:convertUnderlyingSinkStartCallback(o,r,`${t} has member 'start' that`),write:l===undefined?undefined:convertUnderlyingSinkWriteCallback(l,r,`${t} has member 'write' that`),type:i}}function convertUnderlyingSinkAbortCallback(r,t,n){assertFunction(r,n);return n=>promiseCall(r,t,[n])}function convertUnderlyingSinkCloseCallback(r,t,n){assertFunction(r,n);return()=>promiseCall(r,t,[])}function convertUnderlyingSinkStartCallback(r,t,n){assertFunction(r,n);return n=>reflectCall(r,t,[n])}function convertUnderlyingSinkWriteCallback(r,t,n){assertFunction(r,n);return(n,a)=>promiseCall(r,t,[n,a])}function assertWritableStream(r,t){if(!IsWritableStream(r)){throw new TypeError(`${t} is not a WritableStream.`)}}function isAbortSignal(r){if(typeof r!=="object"||r===null){return false}try{return typeof r.aborted==="boolean"}catch(r){return false}}const _=typeof AbortController==="function";function createAbortController(){if(_){return new AbortController}return undefined}class WritableStream{constructor(r={},t={}){if(r===undefined){r=null}else{assertObject(r,"First parameter")}const n=convertQueuingStrategy(t,"Second parameter");const a=convertUnderlyingSink(r,"First parameter");InitializeWritableStream(this);const o=a.type;if(o!==undefined){throw new RangeError("Invalid type is specified")}const i=ExtractSizeAlgorithm(n);const l=ExtractHighWaterMark(n,1);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,a,l,i)}get locked(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("locked")}return IsWritableStreamLocked(this)}abort(r=undefined){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("abort"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"))}return WritableStreamAbort(this,r)}close(){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("close"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"))}if(WritableStreamCloseQueuedOrInFlight(this)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamClose(this)}getWriter(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("getWriter")}return AcquireWritableStreamDefaultWriter(this)}}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:true},close:{enumerable:true},getWriter:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStream.prototype,t.toStringTag,{value:"WritableStream",configurable:true})}function AcquireWritableStreamDefaultWriter(r){return new WritableStreamDefaultWriter(r)}function CreateWritableStream(r,t,n,a,o=1,i=(()=>1)){const l=Object.create(WritableStream.prototype);InitializeWritableStream(l);const s=Object.create(WritableStreamDefaultController.prototype);SetUpWritableStreamDefaultController(l,s,r,t,n,a,o,i);return l}function InitializeWritableStream(r){r._state="writable";r._storedError=undefined;r._writer=undefined;r._writableStreamController=undefined;r._writeRequests=new SimpleQueue;r._inFlightWriteRequest=undefined;r._closeRequest=undefined;r._inFlightCloseRequest=undefined;r._pendingAbortRequest=undefined;r._backpressure=false}function IsWritableStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")){return false}return r instanceof WritableStream}function IsWritableStreamLocked(r){if(r._writer===undefined){return false}return true}function WritableStreamAbort(r,t){var n;if(r._state==="closed"||r._state==="errored"){return promiseResolvedWith(undefined)}r._writableStreamController._abortReason=t;(n=r._writableStreamController._abortController)===null||n===void 0?void 0:n.abort();const a=r._state;if(a==="closed"||a==="errored"){return promiseResolvedWith(undefined)}if(r._pendingAbortRequest!==undefined){return r._pendingAbortRequest._promise}let o=false;if(a==="erroring"){o=true;t=undefined}const i=newPromise(((n,a)=>{r._pendingAbortRequest={_promise:undefined,_resolve:n,_reject:a,_reason:t,_wasAlreadyErroring:o}}));r._pendingAbortRequest._promise=i;if(!o){WritableStreamStartErroring(r,t)}return i}function WritableStreamClose(r){const t=r._state;if(t==="closed"||t==="errored"){return promiseRejectedWith(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`))}const n=newPromise(((t,n)=>{const a={_resolve:t,_reject:n};r._closeRequest=a}));const a=r._writer;if(a!==undefined&&r._backpressure&&t==="writable"){defaultWriterReadyPromiseResolve(a)}WritableStreamDefaultControllerClose(r._writableStreamController);return n}function WritableStreamAddWriteRequest(r){const t=newPromise(((t,n)=>{const a={_resolve:t,_reject:n};r._writeRequests.push(a)}));return t}function WritableStreamDealWithRejection(r,t){const n=r._state;if(n==="writable"){WritableStreamStartErroring(r,t);return}WritableStreamFinishErroring(r)}function WritableStreamStartErroring(r,t){const n=r._writableStreamController;r._state="erroring";r._storedError=t;const a=r._writer;if(a!==undefined){WritableStreamDefaultWriterEnsureReadyPromiseRejected(a,t)}if(!WritableStreamHasOperationMarkedInFlight(r)&&n._started){WritableStreamFinishErroring(r)}}function WritableStreamFinishErroring(r){r._state="errored";r._writableStreamController[m]();const t=r._storedError;r._writeRequests.forEach((r=>{r._reject(t)}));r._writeRequests=new SimpleQueue;if(r._pendingAbortRequest===undefined){WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}const n=r._pendingAbortRequest;r._pendingAbortRequest=undefined;if(n._wasAlreadyErroring){n._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}const a=r._writableStreamController[c](n._reason);uponPromise(a,(()=>{n._resolve();WritableStreamRejectCloseAndClosedPromiseIfNeeded(r)}),(t=>{n._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(r)}))}function WritableStreamFinishInFlightWrite(r){r._inFlightWriteRequest._resolve(undefined);r._inFlightWriteRequest=undefined}function WritableStreamFinishInFlightWriteWithError(r,t){r._inFlightWriteRequest._reject(t);r._inFlightWriteRequest=undefined;WritableStreamDealWithRejection(r,t)}function WritableStreamFinishInFlightClose(r){r._inFlightCloseRequest._resolve(undefined);r._inFlightCloseRequest=undefined;const t=r._state;if(t==="erroring"){r._storedError=undefined;if(r._pendingAbortRequest!==undefined){r._pendingAbortRequest._resolve();r._pendingAbortRequest=undefined}}r._state="closed";const n=r._writer;if(n!==undefined){defaultWriterClosedPromiseResolve(n)}}function WritableStreamFinishInFlightCloseWithError(r,t){r._inFlightCloseRequest._reject(t);r._inFlightCloseRequest=undefined;if(r._pendingAbortRequest!==undefined){r._pendingAbortRequest._reject(t);r._pendingAbortRequest=undefined}WritableStreamDealWithRejection(r,t)}function WritableStreamCloseQueuedOrInFlight(r){if(r._closeRequest===undefined&&r._inFlightCloseRequest===undefined){return false}return true}function WritableStreamHasOperationMarkedInFlight(r){if(r._inFlightWriteRequest===undefined&&r._inFlightCloseRequest===undefined){return false}return true}function WritableStreamMarkCloseRequestInFlight(r){r._inFlightCloseRequest=r._closeRequest;r._closeRequest=undefined}function WritableStreamMarkFirstWriteRequestInFlight(r){r._inFlightWriteRequest=r._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(r){if(r._closeRequest!==undefined){r._closeRequest._reject(r._storedError);r._closeRequest=undefined}const t=r._writer;if(t!==undefined){defaultWriterClosedPromiseReject(t,r._storedError)}}function WritableStreamUpdateBackpressure(r,t){const n=r._writer;if(n!==undefined&&t!==r._backpressure){if(t){defaultWriterReadyPromiseReset(n)}else{defaultWriterReadyPromiseResolve(n)}}r._backpressure=t}class WritableStreamDefaultWriter{constructor(r){assertRequiredArgument(r,1,"WritableStreamDefaultWriter");assertWritableStream(r,"First parameter");if(IsWritableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive writing by another writer")}this._ownerWritableStream=r;r._writer=this;const t=r._state;if(t==="writable"){if(!WritableStreamCloseQueuedOrInFlight(r)&&r._backpressure){defaultWriterReadyPromiseInitialize(this)}else{defaultWriterReadyPromiseInitializeAsResolved(this)}defaultWriterClosedPromiseInitialize(this)}else if(t==="erroring"){defaultWriterReadyPromiseInitializeAsRejected(this,r._storedError);defaultWriterClosedPromiseInitialize(this)}else if(t==="closed"){defaultWriterReadyPromiseInitializeAsResolved(this);defaultWriterClosedPromiseInitializeAsResolved(this)}else{const t=r._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,t);defaultWriterClosedPromiseInitializeAsRejected(this,t)}}get closed(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("closed"))}return this._closedPromise}get desiredSize(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("desiredSize")}if(this._ownerWritableStream===undefined){throw defaultWriterLockException("desiredSize")}return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("ready"))}return this._readyPromise}abort(r=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("abort"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("abort"))}return WritableStreamDefaultWriterAbort(this,r)}close(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("close"))}const r=this._ownerWritableStream;if(r===undefined){return promiseRejectedWith(defaultWriterLockException("close"))}if(WritableStreamCloseQueuedOrInFlight(r)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("releaseLock")}const r=this._ownerWritableStream;if(r===undefined){return}WritableStreamDefaultWriterRelease(this)}write(r=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("write"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("write to"))}return WritableStreamDefaultWriterWrite(this,r)}}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:true},close:{enumerable:true},releaseLock:{enumerable:true},write:{enumerable:true},closed:{enumerable:true},desiredSize:{enumerable:true},ready:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultWriter.prototype,t.toStringTag,{value:"WritableStreamDefaultWriter",configurable:true})}function IsWritableStreamDefaultWriter(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")){return false}return r instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterAbort(r,t){const n=r._ownerWritableStream;return WritableStreamAbort(n,t)}function WritableStreamDefaultWriterClose(r){const t=r._ownerWritableStream;return WritableStreamClose(t)}function WritableStreamDefaultWriterCloseWithErrorPropagation(r){const t=r._ownerWritableStream;const n=t._state;if(WritableStreamCloseQueuedOrInFlight(t)||n==="closed"){return promiseResolvedWith(undefined)}if(n==="errored"){return promiseRejectedWith(t._storedError)}return WritableStreamDefaultWriterClose(r)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,t){if(r._closedPromiseState==="pending"){defaultWriterClosedPromiseReject(r,t)}else{defaultWriterClosedPromiseResetToRejected(r,t)}}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,t){if(r._readyPromiseState==="pending"){defaultWriterReadyPromiseReject(r,t)}else{defaultWriterReadyPromiseResetToRejected(r,t)}}function WritableStreamDefaultWriterGetDesiredSize(r){const t=r._ownerWritableStream;const n=t._state;if(n==="errored"||n==="erroring"){return null}if(n==="closed"){return 0}return WritableStreamDefaultControllerGetDesiredSize(t._writableStreamController)}function WritableStreamDefaultWriterRelease(r){const t=r._ownerWritableStream;const n=new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,n);WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,n);t._writer=undefined;r._ownerWritableStream=undefined}function WritableStreamDefaultWriterWrite(r,t){const n=r._ownerWritableStream;const a=n._writableStreamController;const o=WritableStreamDefaultControllerGetChunkSize(a,t);if(n!==r._ownerWritableStream){return promiseRejectedWith(defaultWriterLockException("write to"))}const i=n._state;if(i==="errored"){return promiseRejectedWith(n._storedError)}if(WritableStreamCloseQueuedOrInFlight(n)||i==="closed"){return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"))}if(i==="erroring"){return promiseRejectedWith(n._storedError)}const l=WritableStreamAddWriteRequest(n);WritableStreamDefaultControllerWrite(a,t,o);return l}const C={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("abortReason")}return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("signal")}if(this._abortController===undefined){throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported")}return this._abortController.signal}error(r=undefined){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("error")}const t=this._controlledWritableStream._state;if(t!=="writable"){return}WritableStreamDefaultControllerError(this,r)}[c](r){const t=this._abortAlgorithm(r);WritableStreamDefaultControllerClearAlgorithms(this);return t}[m](){ResetQueue(this)}}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:true},signal:{enumerable:true},error:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultController.prototype,t.toStringTag,{value:"WritableStreamDefaultController",configurable:true})}function IsWritableStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")){return false}return r instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(r,t,n,a,o,i,l,s){t._controlledWritableStream=r;r._writableStreamController=t;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._abortReason=undefined;t._abortController=createAbortController();t._started=false;t._strategySizeAlgorithm=s;t._strategyHWM=l;t._writeAlgorithm=a;t._closeAlgorithm=o;t._abortAlgorithm=i;const u=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(r,u);const d=n();const c=promiseResolvedWith(d);uponPromise(c,(()=>{t._started=true;WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}),(n=>{t._started=true;WritableStreamDealWithRejection(r,n)}))}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(r,t,n,a){const o=Object.create(WritableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let writeAlgorithm=()=>promiseResolvedWith(undefined);let closeAlgorithm=()=>promiseResolvedWith(undefined);let abortAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.write!==undefined){writeAlgorithm=r=>t.write(r,o)}if(t.close!==undefined){closeAlgorithm=()=>t.close()}if(t.abort!==undefined){abortAlgorithm=r=>t.abort(r)}SetUpWritableStreamDefaultController(r,o,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,n,a)}function WritableStreamDefaultControllerClearAlgorithms(r){r._writeAlgorithm=undefined;r._closeAlgorithm=undefined;r._abortAlgorithm=undefined;r._strategySizeAlgorithm=undefined}function WritableStreamDefaultControllerClose(r){EnqueueValueWithSize(r,C,0);WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerGetChunkSize(r,t){try{return r._strategySizeAlgorithm(t)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(r,t);return 1}}function WritableStreamDefaultControllerGetDesiredSize(r){return r._strategyHWM-r._queueTotalSize}function WritableStreamDefaultControllerWrite(r,t,n){try{EnqueueValueWithSize(r,t,n)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(r,t);return}const a=r._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(a)&&a._state==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(a,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(r){const t=r._controlledWritableStream;if(!r._started){return}if(t._inFlightWriteRequest!==undefined){return}const n=t._state;if(n==="erroring"){WritableStreamFinishErroring(t);return}if(r._queue.length===0){return}const a=PeekQueueValue(r);if(a===C){WritableStreamDefaultControllerProcessClose(r)}else{WritableStreamDefaultControllerProcessWrite(r,a)}}function WritableStreamDefaultControllerErrorIfNeeded(r,t){if(r._controlledWritableStream._state==="writable"){WritableStreamDefaultControllerError(r,t)}}function WritableStreamDefaultControllerProcessClose(r){const t=r._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(t);DequeueValue(r);const n=r._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(r);uponPromise(n,(()=>{WritableStreamFinishInFlightClose(t)}),(r=>{WritableStreamFinishInFlightCloseWithError(t,r)}))}function WritableStreamDefaultControllerProcessWrite(r,t){const n=r._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(n);const a=r._writeAlgorithm(t);uponPromise(a,(()=>{WritableStreamFinishInFlightWrite(n);const t=n._state;DequeueValue(r);if(!WritableStreamCloseQueuedOrInFlight(n)&&t==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(n,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}),(t=>{if(n._state==="writable"){WritableStreamDefaultControllerClearAlgorithms(r)}WritableStreamFinishInFlightWriteWithError(n,t)}))}function WritableStreamDefaultControllerGetBackpressure(r){const t=WritableStreamDefaultControllerGetDesiredSize(r);return t<=0}function WritableStreamDefaultControllerError(r,t){const n=r._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(r);WritableStreamStartErroring(n,t)}function streamBrandCheckException$2(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(r){return new TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(r){r._closedPromise=newPromise(((t,n)=>{r._closedPromise_resolve=t;r._closedPromise_reject=n;r._closedPromiseState="pending"}))}function defaultWriterClosedPromiseInitializeAsRejected(r,t){defaultWriterClosedPromiseInitialize(r);defaultWriterClosedPromiseReject(r,t)}function defaultWriterClosedPromiseInitializeAsResolved(r){defaultWriterClosedPromiseInitialize(r);defaultWriterClosedPromiseResolve(r)}function defaultWriterClosedPromiseReject(r,t){if(r._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._closedPromise);r._closedPromise_reject(t);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined;r._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(r,t){defaultWriterClosedPromiseInitializeAsRejected(r,t)}function defaultWriterClosedPromiseResolve(r){if(r._closedPromise_resolve===undefined){return}r._closedPromise_resolve(undefined);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined;r._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(r){r._readyPromise=newPromise(((t,n)=>{r._readyPromise_resolve=t;r._readyPromise_reject=n}));r._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(r,t){defaultWriterReadyPromiseInitialize(r);defaultWriterReadyPromiseReject(r,t)}function defaultWriterReadyPromiseInitializeAsResolved(r){defaultWriterReadyPromiseInitialize(r);defaultWriterReadyPromiseResolve(r)}function defaultWriterReadyPromiseReject(r,t){if(r._readyPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._readyPromise);r._readyPromise_reject(t);r._readyPromise_resolve=undefined;r._readyPromise_reject=undefined;r._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(r){defaultWriterReadyPromiseInitialize(r)}function defaultWriterReadyPromiseResetToRejected(r,t){defaultWriterReadyPromiseInitializeAsRejected(r,t)}function defaultWriterReadyPromiseResolve(r){if(r._readyPromise_resolve===undefined){return}r._readyPromise_resolve(undefined);r._readyPromise_resolve=undefined;r._readyPromise_reject=undefined;r._readyPromiseState="fulfilled"}const w=typeof DOMException!=="undefined"?DOMException:undefined;function isDOMExceptionConstructor(r){if(!(typeof r==="function"||typeof r==="object")){return false}try{new r;return true}catch(r){return false}}function createDOMExceptionPolyfill(){const r=function DOMException(r,t){this.message=r||"";this.name=t||"Error";if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}};r.prototype=Object.create(Error.prototype);Object.defineProperty(r.prototype,"constructor",{value:r,writable:true,configurable:true});return r}const W=isDOMExceptionConstructor(w)?w:createDOMExceptionPolyfill();function ReadableStreamPipeTo(r,t,n,a,o,i){const l=AcquireReadableStreamDefaultReader(r);const s=AcquireWritableStreamDefaultWriter(t);r._disturbed=true;let u=false;let d=promiseResolvedWith(undefined);return newPromise(((c,m)=>{let b;if(i!==undefined){b=()=>{const n=new W("Aborted","AbortError");const i=[];if(!a){i.push((()=>{if(t._state==="writable"){return WritableStreamAbort(t,n)}return promiseResolvedWith(undefined)}))}if(!o){i.push((()=>{if(r._state==="readable"){return ReadableStreamCancel(r,n)}return promiseResolvedWith(undefined)}))}shutdownWithAction((()=>Promise.all(i.map((r=>r())))),true,n)};if(i.aborted){b();return}i.addEventListener("abort",b)}function pipeLoop(){return newPromise(((r,t)=>{function next(n){if(n){r()}else{PerformPromiseThen(pipeStep(),next,t)}}next(false)}))}function pipeStep(){if(u){return promiseResolvedWith(true)}return PerformPromiseThen(s._readyPromise,(()=>newPromise(((r,t)=>{ReadableStreamDefaultReaderRead(l,{_chunkSteps:t=>{d=PerformPromiseThen(WritableStreamDefaultWriterWrite(s,t),undefined,noop);r(false)},_closeSteps:()=>r(true),_errorSteps:t})}))))}isOrBecomesErrored(r,l._closedPromise,(r=>{if(!a){shutdownWithAction((()=>WritableStreamAbort(t,r)),true,r)}else{shutdown(true,r)}}));isOrBecomesErrored(t,s._closedPromise,(t=>{if(!o){shutdownWithAction((()=>ReadableStreamCancel(r,t)),true,t)}else{shutdown(true,t)}}));isOrBecomesClosed(r,l._closedPromise,(()=>{if(!n){shutdownWithAction((()=>WritableStreamDefaultWriterCloseWithErrorPropagation(s)))}else{shutdown()}}));if(WritableStreamCloseQueuedOrInFlight(t)||t._state==="closed"){const t=new TypeError("the destination writable stream closed before all data could be piped to it");if(!o){shutdownWithAction((()=>ReadableStreamCancel(r,t)),true,t)}else{shutdown(true,t)}}setPromiseIsHandledToTrue(pipeLoop());function waitForWritesToFinish(){const r=d;return PerformPromiseThen(d,(()=>r!==d?waitForWritesToFinish():undefined))}function isOrBecomesErrored(r,t,n){if(r._state==="errored"){n(r._storedError)}else{uponRejection(t,n)}}function isOrBecomesClosed(r,t,n){if(r._state==="closed"){n()}else{uponFulfillment(t,n)}}function shutdownWithAction(r,n,a){if(u){return}u=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),doTheRest)}else{doTheRest()}function doTheRest(){uponPromise(r(),(()=>finalize(n,a)),(r=>finalize(true,r)))}}function shutdown(r,n){if(u){return}u=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),(()=>finalize(r,n)))}else{finalize(r,n)}}function finalize(r,t){WritableStreamDefaultWriterRelease(s);ReadableStreamReaderGenericRelease(l);if(i!==undefined){i.removeEventListener("abort",b)}if(r){m(t)}else{c(undefined)}}}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("desiredSize")}return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("close")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits close")}ReadableStreamDefaultControllerClose(this)}enqueue(r=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("enqueue")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits enqueue")}return ReadableStreamDefaultControllerEnqueue(this,r)}error(r=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("error")}ReadableStreamDefaultControllerError(this,r)}[b](r){ResetQueue(this);const t=this._cancelAlgorithm(r);ReadableStreamDefaultControllerClearAlgorithms(this);return t}[h](r){const t=this._controlledReadableStream;if(this._queue.length>0){const n=DequeueValue(this);if(this._closeRequested&&this._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(this);ReadableStreamClose(t)}else{ReadableStreamDefaultControllerCallPullIfNeeded(this)}r._chunkSteps(n)}else{ReadableStreamAddReadRequest(t,r);ReadableStreamDefaultControllerCallPullIfNeeded(this)}}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultController.prototype,t.toStringTag,{value:"ReadableStreamDefaultController",configurable:true})}function IsReadableStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")){return false}return r instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(r){const t=ReadableStreamDefaultControllerShouldCallPull(r);if(!t){return}if(r._pulling){r._pullAgain=true;return}r._pulling=true;const n=r._pullAlgorithm();uponPromise(n,(()=>{r._pulling=false;if(r._pullAgain){r._pullAgain=false;ReadableStreamDefaultControllerCallPullIfNeeded(r)}}),(t=>{ReadableStreamDefaultControllerError(r,t)}))}function ReadableStreamDefaultControllerShouldCallPull(r){const t=r._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return false}if(!r._started){return false}if(IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}const n=ReadableStreamDefaultControllerGetDesiredSize(r);if(n>0){return true}return false}function ReadableStreamDefaultControllerClearAlgorithms(r){r._pullAlgorithm=undefined;r._cancelAlgorithm=undefined;r._strategySizeAlgorithm=undefined}function ReadableStreamDefaultControllerClose(r){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return}const t=r._controlledReadableStream;r._closeRequested=true;if(r._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(r);ReadableStreamClose(t)}}function ReadableStreamDefaultControllerEnqueue(r,t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return}const n=r._controlledReadableStream;if(IsReadableStreamLocked(n)&&ReadableStreamGetNumReadRequests(n)>0){ReadableStreamFulfillReadRequest(n,t,false)}else{let n;try{n=r._strategySizeAlgorithm(t)}catch(t){ReadableStreamDefaultControllerError(r,t);throw t}try{EnqueueValueWithSize(r,t,n)}catch(t){ReadableStreamDefaultControllerError(r,t);throw t}}ReadableStreamDefaultControllerCallPullIfNeeded(r)}function ReadableStreamDefaultControllerError(r,t){const n=r._controlledReadableStream;if(n._state!=="readable"){return}ResetQueue(r);ReadableStreamDefaultControllerClearAlgorithms(r);ReadableStreamError(n,t)}function ReadableStreamDefaultControllerGetDesiredSize(r){const t=r._controlledReadableStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return r._strategyHWM-r._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(r){if(ReadableStreamDefaultControllerShouldCallPull(r)){return false}return true}function ReadableStreamDefaultControllerCanCloseOrEnqueue(r){const t=r._controlledReadableStream._state;if(!r._closeRequested&&t==="readable"){return true}return false}function SetUpReadableStreamDefaultController(r,t,n,a,o,i,l){t._controlledReadableStream=r;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._started=false;t._closeRequested=false;t._pullAgain=false;t._pulling=false;t._strategySizeAlgorithm=l;t._strategyHWM=i;t._pullAlgorithm=a;t._cancelAlgorithm=o;r._readableStreamController=t;const s=n();uponPromise(promiseResolvedWith(s),(()=>{t._started=true;ReadableStreamDefaultControllerCallPullIfNeeded(t)}),(r=>{ReadableStreamDefaultControllerError(t,r)}))}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(r,t,n,a){const o=Object.create(ReadableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(o)}if(t.cancel!==undefined){cancelAlgorithm=r=>t.cancel(r)}SetUpReadableStreamDefaultController(r,o,startAlgorithm,pullAlgorithm,cancelAlgorithm,n,a)}function defaultControllerBrandCheckException$1(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(r,t){if(IsReadableByteStreamController(r._readableStreamController)){return ReadableByteStreamTee(r)}return ReadableStreamDefaultTee(r)}function ReadableStreamDefaultTee(r,t){const n=AcquireReadableStreamDefaultReader(r);let a=false;let o=false;let i=false;let l=false;let s;let d;let c;let m;let b;const h=newPromise((r=>{b=r}));function pullAlgorithm(){if(a){o=true;return promiseResolvedWith(undefined)}a=true;const r={_chunkSteps:r=>{u((()=>{o=false;const t=r;const n=r;if(!i){ReadableStreamDefaultControllerEnqueue(c._readableStreamController,t)}if(!l){ReadableStreamDefaultControllerEnqueue(m._readableStreamController,n)}a=false;if(o){pullAlgorithm()}}))},_closeSteps:()=>{a=false;if(!i){ReadableStreamDefaultControllerClose(c._readableStreamController)}if(!l){ReadableStreamDefaultControllerClose(m._readableStreamController)}if(!i||!l){b(undefined)}},_errorSteps:()=>{a=false}};ReadableStreamDefaultReaderRead(n,r);return promiseResolvedWith(undefined)}function cancel1Algorithm(t){i=true;s=t;if(l){const t=CreateArrayFromList([s,d]);const n=ReadableStreamCancel(r,t);b(n)}return h}function cancel2Algorithm(t){l=true;d=t;if(i){const t=CreateArrayFromList([s,d]);const n=ReadableStreamCancel(r,t);b(n)}return h}function startAlgorithm(){}c=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel1Algorithm);m=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm);uponRejection(n._closedPromise,(r=>{ReadableStreamDefaultControllerError(c._readableStreamController,r);ReadableStreamDefaultControllerError(m._readableStreamController,r);if(!i||!l){b(undefined)}}));return[c,m]}function ReadableByteStreamTee(r){let t=AcquireReadableStreamDefaultReader(r);let n=false;let a=false;let o=false;let i=false;let l=false;let s;let d;let c;let m;let b;const h=newPromise((r=>{b=r}));function forwardReaderError(r){uponRejection(r._closedPromise,(n=>{if(r!==t){return}ReadableByteStreamControllerError(c._readableStreamController,n);ReadableByteStreamControllerError(m._readableStreamController,n);if(!i||!l){b(undefined)}}))}function pullWithDefaultReader(){if(IsReadableStreamBYOBReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamDefaultReader(r);forwardReaderError(t)}const s={_chunkSteps:t=>{u((()=>{a=false;o=false;const s=t;let u=t;if(!i&&!l){try{u=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(c._readableStreamController,t);ReadableByteStreamControllerError(m._readableStreamController,t);b(ReadableStreamCancel(r,t));return}}if(!i){ReadableByteStreamControllerEnqueue(c._readableStreamController,s)}if(!l){ReadableByteStreamControllerEnqueue(m._readableStreamController,u)}n=false;if(a){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:()=>{n=false;if(!i){ReadableByteStreamControllerClose(c._readableStreamController)}if(!l){ReadableByteStreamControllerClose(m._readableStreamController)}if(c._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(c._readableStreamController,0)}if(m._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(m._readableStreamController,0)}if(!i||!l){b(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamDefaultReaderRead(t,s)}function pullWithBYOBReader(s,d){if(IsReadableStreamDefaultReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamBYOBReader(r);forwardReaderError(t)}const h=d?m:c;const p=d?c:m;const S={_chunkSteps:t=>{u((()=>{a=false;o=false;const s=d?l:i;const u=d?i:l;if(!u){let n;try{n=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(h._readableStreamController,t);ReadableByteStreamControllerError(p._readableStreamController,t);b(ReadableStreamCancel(r,t));return}if(!s){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,t)}ReadableByteStreamControllerEnqueue(p._readableStreamController,n)}else if(!s){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,t)}n=false;if(a){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:r=>{n=false;const t=d?l:i;const a=d?i:l;if(!t){ReadableByteStreamControllerClose(h._readableStreamController)}if(!a){ReadableByteStreamControllerClose(p._readableStreamController)}if(r!==undefined){if(!t){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,r)}if(!a&&p._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(p._readableStreamController,0)}}if(!t||!a){b(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamBYOBReaderRead(t,s,S)}function pull1Algorithm(){if(n){a=true;return promiseResolvedWith(undefined)}n=true;const r=ReadableByteStreamControllerGetBYOBRequest(c._readableStreamController);if(r===null){pullWithDefaultReader()}else{pullWithBYOBReader(r._view,false)}return promiseResolvedWith(undefined)}function pull2Algorithm(){if(n){o=true;return promiseResolvedWith(undefined)}n=true;const r=ReadableByteStreamControllerGetBYOBRequest(m._readableStreamController);if(r===null){pullWithDefaultReader()}else{pullWithBYOBReader(r._view,true)}return promiseResolvedWith(undefined)}function cancel1Algorithm(t){i=true;s=t;if(l){const t=CreateArrayFromList([s,d]);const n=ReadableStreamCancel(r,t);b(n)}return h}function cancel2Algorithm(t){l=true;d=t;if(i){const t=CreateArrayFromList([s,d]);const n=ReadableStreamCancel(r,t);b(n)}return h}function startAlgorithm(){return}c=CreateReadableByteStream(startAlgorithm,pull1Algorithm,cancel1Algorithm);m=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm);forwardReaderError(t);return[c,m]}function convertUnderlyingDefaultOrByteSource(r,t){assertDictionary(r,t);const n=r;const a=n===null||n===void 0?void 0:n.autoAllocateChunkSize;const o=n===null||n===void 0?void 0:n.cancel;const i=n===null||n===void 0?void 0:n.pull;const l=n===null||n===void 0?void 0:n.start;const s=n===null||n===void 0?void 0:n.type;return{autoAllocateChunkSize:a===undefined?undefined:convertUnsignedLongLongWithEnforceRange(a,`${t} has member 'autoAllocateChunkSize' that`),cancel:o===undefined?undefined:convertUnderlyingSourceCancelCallback(o,n,`${t} has member 'cancel' that`),pull:i===undefined?undefined:convertUnderlyingSourcePullCallback(i,n,`${t} has member 'pull' that`),start:l===undefined?undefined:convertUnderlyingSourceStartCallback(l,n,`${t} has member 'start' that`),type:s===undefined?undefined:convertReadableStreamType(s,`${t} has member 'type' that`)}}function convertUnderlyingSourceCancelCallback(r,t,n){assertFunction(r,n);return n=>promiseCall(r,t,[n])}function convertUnderlyingSourcePullCallback(r,t,n){assertFunction(r,n);return n=>promiseCall(r,t,[n])}function convertUnderlyingSourceStartCallback(r,t,n){assertFunction(r,n);return n=>reflectCall(r,t,[n])}function convertReadableStreamType(r,t){r=`${r}`;if(r!=="bytes"){throw new TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamType`)}return r}function convertReaderOptions(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.mode;return{mode:n===undefined?undefined:convertReadableStreamReaderMode(n,`${t} has member 'mode' that`)}}function convertReadableStreamReaderMode(r,t){r=`${r}`;if(r!=="byob"){throw new TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`)}return r}function convertIteratorOptions(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.preventCancel;return{preventCancel:Boolean(n)}}function convertPipeOptions(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.preventAbort;const a=r===null||r===void 0?void 0:r.preventCancel;const o=r===null||r===void 0?void 0:r.preventClose;const i=r===null||r===void 0?void 0:r.signal;if(i!==undefined){assertAbortSignal(i,`${t} has member 'signal' that`)}return{preventAbort:Boolean(n),preventCancel:Boolean(a),preventClose:Boolean(o),signal:i}}function assertAbortSignal(r,t){if(!isAbortSignal(r)){throw new TypeError(`${t} is not an AbortSignal.`)}}function convertReadableWritablePair(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.readable;assertRequiredField(n,"readable","ReadableWritablePair");assertReadableStream(n,`${t} has member 'readable' that`);const a=r===null||r===void 0?void 0:r.writable;assertRequiredField(a,"writable","ReadableWritablePair");assertWritableStream(a,`${t} has member 'writable' that`);return{readable:n,writable:a}}class ReadableStream{constructor(r={},t={}){if(r===undefined){r=null}else{assertObject(r,"First parameter")}const n=convertQueuingStrategy(t,"Second parameter");const a=convertUnderlyingDefaultOrByteSource(r,"First parameter");InitializeReadableStream(this);if(a.type==="bytes"){if(n.size!==undefined){throw new RangeError("The strategy for a byte stream cannot have a size function")}const r=ExtractHighWaterMark(n,0);SetUpReadableByteStreamControllerFromUnderlyingSource(this,a,r)}else{const r=ExtractSizeAlgorithm(n);const t=ExtractHighWaterMark(n,1);SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,a,t,r)}}get locked(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("locked")}return IsReadableStreamLocked(this)}cancel(r=undefined){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("cancel"))}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"))}return ReadableStreamCancel(this,r)}getReader(r=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("getReader")}const t=convertReaderOptions(r,"First parameter");if(t.mode===undefined){return AcquireReadableStreamDefaultReader(this)}return AcquireReadableStreamBYOBReader(this)}pipeThrough(r,t={}){if(!IsReadableStream(this)){throw streamBrandCheckException$1("pipeThrough")}assertRequiredArgument(r,1,"pipeThrough");const n=convertReadableWritablePair(r,"First parameter");const a=convertPipeOptions(t,"Second parameter");if(IsReadableStreamLocked(this)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream")}if(IsWritableStreamLocked(n.writable)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream")}const o=ReadableStreamPipeTo(this,n.writable,a.preventClose,a.preventAbort,a.preventCancel,a.signal);setPromiseIsHandledToTrue(o);return n.readable}pipeTo(r,t={}){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("pipeTo"))}if(r===undefined){return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`)}if(!IsWritableStream(r)){return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`))}let n;try{n=convertPipeOptions(t,"Second parameter")}catch(r){return promiseRejectedWith(r)}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"))}if(IsWritableStreamLocked(r)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"))}return ReadableStreamPipeTo(this,r,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("tee")}const r=ReadableStreamTee(this);return CreateArrayFromList(r)}values(r=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("values")}const t=convertIteratorOptions(r,"First parameter");return AcquireReadableStreamAsyncIterator(this,t.preventCancel)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:true},getReader:{enumerable:true},pipeThrough:{enumerable:true},pipeTo:{enumerable:true},tee:{enumerable:true},values:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStream.prototype,t.toStringTag,{value:"ReadableStream",configurable:true})}if(typeof t.asyncIterator==="symbol"){Object.defineProperty(ReadableStream.prototype,t.asyncIterator,{value:ReadableStream.prototype.values,writable:true,configurable:true})}function CreateReadableStream(r,t,n,a=1,o=(()=>1)){const i=Object.create(ReadableStream.prototype);InitializeReadableStream(i);const l=Object.create(ReadableStreamDefaultController.prototype);SetUpReadableStreamDefaultController(i,l,r,t,n,a,o);return i}function CreateReadableByteStream(r,t,n){const a=Object.create(ReadableStream.prototype);InitializeReadableStream(a);const o=Object.create(ReadableByteStreamController.prototype);SetUpReadableByteStreamController(a,o,r,t,n,0,undefined);return a}function InitializeReadableStream(r){r._state="readable";r._reader=undefined;r._storedError=undefined;r._disturbed=false}function IsReadableStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")){return false}return r instanceof ReadableStream}function IsReadableStreamLocked(r){if(r._reader===undefined){return false}return true}function ReadableStreamCancel(r,t){r._disturbed=true;if(r._state==="closed"){return promiseResolvedWith(undefined)}if(r._state==="errored"){return promiseRejectedWith(r._storedError)}ReadableStreamClose(r);const n=r._reader;if(n!==undefined&&IsReadableStreamBYOBReader(n)){n._readIntoRequests.forEach((r=>{r._closeSteps(undefined)}));n._readIntoRequests=new SimpleQueue}const a=r._readableStreamController[b](t);return transformPromiseWith(a,noop)}function ReadableStreamClose(r){r._state="closed";const t=r._reader;if(t===undefined){return}defaultReaderClosedPromiseResolve(t);if(IsReadableStreamDefaultReader(t)){t._readRequests.forEach((r=>{r._closeSteps()}));t._readRequests=new SimpleQueue}}function ReadableStreamError(r,t){r._state="errored";r._storedError=t;const n=r._reader;if(n===undefined){return}defaultReaderClosedPromiseReject(n,t);if(IsReadableStreamDefaultReader(n)){n._readRequests.forEach((r=>{r._errorSteps(t)}));n._readRequests=new SimpleQueue}else{n._readIntoRequests.forEach((r=>{r._errorSteps(t)}));n._readIntoRequests=new SimpleQueue}}function streamBrandCheckException$1(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.highWaterMark;assertRequiredField(n,"highWaterMark","QueuingStrategyInit");return{highWaterMark:convertUnrestrictedDouble(n)}}const byteLengthSizeFunction=r=>r.byteLength;try{Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:true})}catch(r){}class ByteLengthQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"ByteLengthQueuingStrategy");r=convertQueuingStrategyInit(r,"First parameter");this._byteLengthQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("highWaterMark")}return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("size")}return byteLengthSizeFunction}}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ByteLengthQueuingStrategy.prototype,t.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:true})}function byteLengthBrandCheckException(r){return new TypeError(`ByteLengthQueuingStrategy.prototype.${r} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_byteLengthQueuingStrategyHighWaterMark")){return false}return r instanceof ByteLengthQueuingStrategy}const countSizeFunction=()=>1;try{Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:true})}catch(r){}class CountQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"CountQueuingStrategy");r=convertQueuingStrategyInit(r,"First parameter");this._countQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("highWaterMark")}return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("size")}return countSizeFunction}}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(CountQueuingStrategy.prototype,t.toStringTag,{value:"CountQueuingStrategy",configurable:true})}function countBrandCheckException(r){return new TypeError(`CountQueuingStrategy.prototype.${r} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_countQueuingStrategyHighWaterMark")){return false}return r instanceof CountQueuingStrategy}function convertTransformer(r,t){assertDictionary(r,t);const n=r===null||r===void 0?void 0:r.flush;const a=r===null||r===void 0?void 0:r.readableType;const o=r===null||r===void 0?void 0:r.start;const i=r===null||r===void 0?void 0:r.transform;const l=r===null||r===void 0?void 0:r.writableType;return{flush:n===undefined?undefined:convertTransformerFlushCallback(n,r,`${t} has member 'flush' that`),readableType:a,start:o===undefined?undefined:convertTransformerStartCallback(o,r,`${t} has member 'start' that`),transform:i===undefined?undefined:convertTransformerTransformCallback(i,r,`${t} has member 'transform' that`),writableType:l}}function convertTransformerFlushCallback(r,t,n){assertFunction(r,n);return n=>promiseCall(r,t,[n])}function convertTransformerStartCallback(r,t,n){assertFunction(r,n);return n=>reflectCall(r,t,[n])}function convertTransformerTransformCallback(r,t,n){assertFunction(r,n);return(n,a)=>promiseCall(r,t,[n,a])}class TransformStream{constructor(r={},t={},n={}){if(r===undefined){r=null}const a=convertQueuingStrategy(t,"Second parameter");const o=convertQueuingStrategy(n,"Third parameter");const i=convertTransformer(r,"First parameter");if(i.readableType!==undefined){throw new RangeError("Invalid readableType specified")}if(i.writableType!==undefined){throw new RangeError("Invalid writableType specified")}const l=ExtractHighWaterMark(o,0);const s=ExtractSizeAlgorithm(o);const u=ExtractHighWaterMark(a,1);const d=ExtractSizeAlgorithm(a);let c;const m=newPromise((r=>{c=r}));InitializeTransformStream(this,m,u,d,l,s);SetUpTransformStreamDefaultControllerFromTransformer(this,i);if(i.start!==undefined){c(i.start(this._transformStreamController))}else{c(undefined)}}get readable(){if(!IsTransformStream(this)){throw streamBrandCheckException("readable")}return this._readable}get writable(){if(!IsTransformStream(this)){throw streamBrandCheckException("writable")}return this._writable}}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:true},writable:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStream.prototype,t.toStringTag,{value:"TransformStream",configurable:true})}function InitializeTransformStream(r,t,n,a,o,i){function startAlgorithm(){return t}function writeAlgorithm(t){return TransformStreamDefaultSinkWriteAlgorithm(r,t)}function abortAlgorithm(t){return TransformStreamDefaultSinkAbortAlgorithm(r,t)}function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(r)}r._writable=CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,n,a);function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(r)}function cancelAlgorithm(t){TransformStreamErrorWritableAndUnblockWrite(r,t);return promiseResolvedWith(undefined)}r._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,o,i);r._backpressure=undefined;r._backpressureChangePromise=undefined;r._backpressureChangePromise_resolve=undefined;TransformStreamSetBackpressure(r,true);r._transformStreamController=undefined}function IsTransformStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_transformStreamController")){return false}return r instanceof TransformStream}function TransformStreamError(r,t){ReadableStreamDefaultControllerError(r._readable._readableStreamController,t);TransformStreamErrorWritableAndUnblockWrite(r,t)}function TransformStreamErrorWritableAndUnblockWrite(r,t){TransformStreamDefaultControllerClearAlgorithms(r._transformStreamController);WritableStreamDefaultControllerErrorIfNeeded(r._writable._writableStreamController,t);if(r._backpressure){TransformStreamSetBackpressure(r,false)}}function TransformStreamSetBackpressure(r,t){if(r._backpressureChangePromise!==undefined){r._backpressureChangePromise_resolve()}r._backpressureChangePromise=newPromise((t=>{r._backpressureChangePromise_resolve=t}));r._backpressure=t}class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("desiredSize")}const r=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(r)}enqueue(r=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("enqueue")}TransformStreamDefaultControllerEnqueue(this,r)}error(r=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("error")}TransformStreamDefaultControllerError(this,r)}terminate(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("terminate")}TransformStreamDefaultControllerTerminate(this)}}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:true},error:{enumerable:true},terminate:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStreamDefaultController.prototype,t.toStringTag,{value:"TransformStreamDefaultController",configurable:true})}function IsTransformStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")){return false}return r instanceof TransformStreamDefaultController}function SetUpTransformStreamDefaultController(r,t,n,a){t._controlledTransformStream=r;r._transformStreamController=t;t._transformAlgorithm=n;t._flushAlgorithm=a}function SetUpTransformStreamDefaultControllerFromTransformer(r,t){const n=Object.create(TransformStreamDefaultController.prototype);let transformAlgorithm=r=>{try{TransformStreamDefaultControllerEnqueue(n,r);return promiseResolvedWith(undefined)}catch(r){return promiseRejectedWith(r)}};let flushAlgorithm=()=>promiseResolvedWith(undefined);if(t.transform!==undefined){transformAlgorithm=r=>t.transform(r,n)}if(t.flush!==undefined){flushAlgorithm=()=>t.flush(n)}SetUpTransformStreamDefaultController(r,n,transformAlgorithm,flushAlgorithm)}function TransformStreamDefaultControllerClearAlgorithms(r){r._transformAlgorithm=undefined;r._flushAlgorithm=undefined}function TransformStreamDefaultControllerEnqueue(r,t){const n=r._controlledTransformStream;const a=n._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(a)){throw new TypeError("Readable side is not in a state that permits enqueue")}try{ReadableStreamDefaultControllerEnqueue(a,t)}catch(r){TransformStreamErrorWritableAndUnblockWrite(n,r);throw n._readable._storedError}const o=ReadableStreamDefaultControllerHasBackpressure(a);if(o!==n._backpressure){TransformStreamSetBackpressure(n,true)}}function TransformStreamDefaultControllerError(r,t){TransformStreamError(r._controlledTransformStream,t)}function TransformStreamDefaultControllerPerformTransform(r,t){const n=r._transformAlgorithm(t);return transformPromiseWith(n,undefined,(t=>{TransformStreamError(r._controlledTransformStream,t);throw t}))}function TransformStreamDefaultControllerTerminate(r){const t=r._controlledTransformStream;const n=t._readable._readableStreamController;ReadableStreamDefaultControllerClose(n);const a=new TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(t,a)}function TransformStreamDefaultSinkWriteAlgorithm(r,t){const n=r._transformStreamController;if(r._backpressure){const a=r._backpressureChangePromise;return transformPromiseWith(a,(()=>{const a=r._writable;const o=a._state;if(o==="erroring"){throw a._storedError}return TransformStreamDefaultControllerPerformTransform(n,t)}))}return TransformStreamDefaultControllerPerformTransform(n,t)}function TransformStreamDefaultSinkAbortAlgorithm(r,t){TransformStreamError(r,t);return promiseResolvedWith(undefined)}function TransformStreamDefaultSinkCloseAlgorithm(r){const t=r._readable;const n=r._transformStreamController;const a=n._flushAlgorithm();TransformStreamDefaultControllerClearAlgorithms(n);return transformPromiseWith(a,(()=>{if(t._state==="errored"){throw t._storedError}ReadableStreamDefaultControllerClose(t._readableStreamController)}),(n=>{TransformStreamError(r,n);throw t._storedError}))}function TransformStreamDefaultSourcePullAlgorithm(r){TransformStreamSetBackpressure(r,false);return r._backpressureChangePromise}function defaultControllerBrandCheckException(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(r){return new TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}r.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy;r.CountQueuingStrategy=CountQueuingStrategy;r.ReadableByteStreamController=ReadableByteStreamController;r.ReadableStream=ReadableStream;r.ReadableStreamBYOBReader=ReadableStreamBYOBReader;r.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest;r.ReadableStreamDefaultController=ReadableStreamDefaultController;r.ReadableStreamDefaultReader=ReadableStreamDefaultReader;r.TransformStream=TransformStream;r.TransformStreamDefaultController=TransformStreamDefaultController;r.WritableStream=WritableStream;r.WritableStreamDefaultController=WritableStreamDefaultController;r.WritableStreamDefaultWriter=WritableStreamDefaultWriter;Object.defineProperty(r,"__esModule",{value:true})}))},300:function(r){"use strict";r.exports=require("buffer")},742:function(r){"use strict";r.exports=require("node:process")},477:function(r){"use strict";r.exports=require("node:stream/web")},267:function(r){"use strict";r.exports=require("worker_threads")},930:function(r,t,n){const a=65536;if(!globalThis.ReadableStream){try{const r=n(742);const{emitWarning:t}=r;try{r.emitWarning=()=>{};Object.assign(globalThis,n(477));r.emitWarning=t}catch(n){r.emitWarning=t;throw n}}catch(r){Object.assign(globalThis,n(991))}}try{const{Blob:r}=n(300);if(r&&!r.prototype.stream){r.prototype.stream=function name(r){let t=0;const n=this;return new ReadableStream({type:"bytes",async pull(r){const o=n.slice(t,Math.min(n.size,t+a));const i=await o.arrayBuffer();t+=i.byteLength;r.enqueue(new Uint8Array(i));if(t===n.size){r.close()}}})}}}catch(r){}},931:function(r,t,n){"use strict";var a=n(876);const o=class File extends a.Z{#e=0;#r="";constructor(r,t,n={}){if(arguments.length<2){throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)}super(r,n);if(n===null)n={};const a=n.lastModified===undefined?Date.now():Number(n.lastModified);if(!Number.isNaN(a)){this.#e=a}this.#r=String(t)}get name(){return this.#r}get lastModified(){return this.#e}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](r){return!!r&&r instanceof a.Z&&/^(File)$/.test(r[Symbol.toStringTag])}};const i=o;t["Z"]=i},825:function(r,t,n){"use strict";n.d(t,{t6:function(){return s.Z},$B:function(){return l.Z},xB:function(){return blobFrom},SX:function(){return blobFromSync},e2:function(){return fileFrom},RA:function(){return fileFromSync}});var a=require("node:fs");var o=require("node:path");var i=n(423);var l=n(931);var s=n(876);const{stat:u}=a.promises;const blobFromSync=(r,t)=>fromBlob((0,a.statSync)(r),r,t);const blobFrom=(r,t)=>u(r).then((n=>fromBlob(n,r,t)));const fileFrom=(r,t)=>u(r).then((n=>fromFile(n,r,t)));const fileFromSync=(r,t)=>fromFile((0,a.statSync)(r),r,t);const fromBlob=(r,t,n="")=>new s.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],{type:n});const fromFile=(r,t,n="")=>new l.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],(0,o.basename)(t),{type:n,lastModified:r.mtimeMs});class BlobDataItem{#t;#n;constructor(r){this.#t=r.path;this.#n=r.start;this.size=r.size;this.lastModified=r.lastModified}slice(r,t){return new BlobDataItem({path:this.#t,lastModified:this.lastModified,size:t-r,start:this.#n+r})}async*stream(){const{mtimeMs:r}=await u(this.#t);if(r>this.lastModified){throw new i("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError")}yield*(0,a.createReadStream)(this.#t,{start:this.#n,end:this.#n+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}var d=null&&blobFromSync},876:function(r,t,n){"use strict";var a=n(930);
/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */const o=65536;async function*toIterator(r,t=true){for(const n of r){if("stream"in n){yield*n.stream()}else if(ArrayBuffer.isView(n)){if(t){let r=n.byteOffset;const t=n.byteOffset+n.byteLength;while(r!==t){const a=Math.min(t-r,o);const i=n.buffer.slice(r,r+a);r+=i.byteLength;yield new Uint8Array(i)}}else{yield n}}else{let r=0,t=n;while(r!==t.size){const n=t.slice(r,Math.min(t.size,r+o));const a=await n.arrayBuffer();r+=a.byteLength;yield new Uint8Array(a)}}}}const i=class Blob{#a=[];#o="";#i=0;#l="transparent";constructor(r=[],t={}){if(typeof r!=="object"||r===null){throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.")}if(typeof r[Symbol.iterator]!=="function"){throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.")}if(typeof t!=="object"&&typeof t!=="function"){throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.")}if(t===null)t={};const n=new TextEncoder;for(const t of r){let r;if(ArrayBuffer.isView(t)){r=new Uint8Array(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength))}else if(t instanceof ArrayBuffer){r=new Uint8Array(t.slice(0))}else if(t instanceof Blob){r=t}else{r=n.encode(`${t}`)}this.#i+=ArrayBuffer.isView(r)?r.byteLength:r.size;this.#a.push(r)}this.#l=`${t.endings===undefined?"transparent":t.endings}`;const a=t.type===undefined?"":String(t.type);this.#o=/^[\x20-\x7E]*$/.test(a)?a:""}get size(){return this.#i}get type(){return this.#o}async text(){const r=new TextDecoder;let t="";for await(const n of toIterator(this.#a,false)){t+=r.decode(n,{stream:true})}t+=r.decode();return t}async arrayBuffer(){const r=new Uint8Array(this.size);let t=0;for await(const n of toIterator(this.#a,false)){r.set(n,t);t+=n.length}return r.buffer}stream(){const r=toIterator(this.#a,true);return new globalThis.ReadableStream({type:"bytes",async pull(t){const n=await r.next();n.done?t.close():t.enqueue(n.value)},async cancel(){await r.return()}})}slice(r=0,t=this.size,n=""){const{size:a}=this;let o=r<0?Math.max(a+r,0):Math.min(r,a);let i=t<0?Math.max(a+t,0):Math.min(t,a);const l=Math.max(i-o,0);const s=this.#a;const u=[];let d=0;for(const r of s){if(d>=l){break}const t=ArrayBuffer.isView(r)?r.byteLength:r.size;if(o&&t<=o){o-=t;i-=t}else{let n;if(ArrayBuffer.isView(r)){n=r.subarray(o,Math.min(t,i));d+=n.byteLength}else{n=r.slice(o,Math.min(t,i));d+=n.size}i-=t;u.push(n);o=0}}const c=new Blob([],{type:String(n).toLowerCase()});c.#i=l;c.#a=u;return c}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](r){return r&&typeof r==="object"&&typeof r.constructor==="function"&&(typeof r.stream==="function"||typeof r.arrayBuffer==="function")&&/^(Blob|File)$/.test(r[Symbol.toStringTag])}};Object.defineProperties(i.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}});const l=i;t["Z"]=l},648:function(r,t,n){"use strict";n.d(t,{Ct:function(){return m},au:function(){return formDataToBlob}});var a=n(876);var o=n(931);
/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var{toStringTag:i,iterator:l,hasInstance:s}=Symbol,u=Math.random,d="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=(r,t,n)=>(r+="",/^(Blob|File)$/.test(t&&t[i])?[(n=n!==void 0?n+"":t[i]=="File"?t.name:"blob",r),t.name!==n||t[i]=="blob"?new o.Z([t],n,t):t]:[r,t+""]),e=(r,t)=>(t?r:r.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),x=(r,t,n)=>{if(t.length<n){throw new TypeError(`Failed to execute '${r}' on 'FormData': ${n} arguments required, but only ${t.length} present.`)}};const c=null&&F;const m=class FormData{#s=[];constructor(...r){if(r.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}get[i](){return"FormData"}[l](){return this.entries()}static[s](r){return r&&typeof r==="object"&&r[i]==="FormData"&&!d.some((t=>typeof r[t]!="function"))}append(...r){x("append",arguments,2);this.#s.push(f(...r))}delete(r){x("delete",arguments,1);r+="";this.#s=this.#s.filter((([t])=>t!==r))}get(r){x("get",arguments,1);r+="";for(var t=this.#s,n=t.length,a=0;a<n;a++)if(t[a][0]===r)return t[a][1];return null}getAll(r,t){x("getAll",arguments,1);t=[];r+="";this.#s.forEach((n=>n[0]===r&&t.push(n[1])));return t}has(r){x("has",arguments,1);r+="";return this.#s.some((t=>t[0]===r))}forEach(r,t){x("forEach",arguments,1);for(var[n,a]of this)r.call(t,a,n,this)}set(...r){x("set",arguments,2);var t=[],n=!0;r=f(...r);this.#s.forEach((a=>{a[0]===r[0]?n&&(n=!t.push(r)):t.push(a)}));n&&t.push(r);this.#s=t}*entries(){yield*this.#s}*keys(){for(var[r]of this)yield r}*values(){for(var[,r]of this)yield r}};function formDataToBlob(r,t=a.Z){var n=`${u()}${u()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),o=[],i=`--${n}\r\nContent-Disposition: form-data; name="`;r.forEach(((r,t)=>typeof r=="string"?o.push(i+e(t)+`"\r\n\r\n${r.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):o.push(i+e(t)+`"; filename="${e(r.name,1)}"\r\nContent-Type: ${r.type||"application/octet-stream"}\r\n\r\n`,r,"\r\n")));o.push(`--${n}--`);return new t(o,{type:"multipart/form-data; boundary="+n})}}};var t={};function __nccwpck_require__(n){var a=t[n];if(a!==undefined){return a.exports}var o=t[n]={exports:{}};var i=true;try{r[n].call(o.exports,o,o.exports,__nccwpck_require__);i=false}finally{if(i)delete t[n]}return o.exports}__nccwpck_require__.m=r;!function(){__nccwpck_require__.d=function(r,t){for(var n in t){if(__nccwpck_require__.o(t,n)&&!__nccwpck_require__.o(r,n)){Object.defineProperty(r,n,{enumerable:true,get:t[n]})}}}}();!function(){__nccwpck_require__.f={};__nccwpck_require__.e=function(r){return Promise.all(Object.keys(__nccwpck_require__.f).reduce((function(t,n){__nccwpck_require__.f[n](r,t);return t}),[]))}}();!function(){__nccwpck_require__.u=function(r){return""+r+".index.js"}}();!function(){__nccwpck_require__.o=function(r,t){return Object.prototype.hasOwnProperty.call(r,t)}}();!function(){__nccwpck_require__.r=function(r){if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(r,"__esModule",{value:true})}}();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";!function(){var r={179:1};var installChunk=function(t){var n=t.modules,a=t.ids,o=t.runtime;for(var i in n){if(__nccwpck_require__.o(n,i)){__nccwpck_require__.m[i]=n[i]}}if(o)o(__nccwpck_require__);for(var l=0;l<a.length;l++)r[a[l]]=1};__nccwpck_require__.f.require=function(t,n){if(!r[t]){if(true){installChunk(require("./"+__nccwpck_require__.u(t)))}else r[t]=1}}}();var n={};!function(){"use strict";__nccwpck_require__.r(n);__nccwpck_require__.d(n,{AbortError:function(){return AbortError},Blob:function(){return P.t6},FetchError:function(){return FetchError},File:function(){return P.$B},FormData:function(){return d.Ct},Headers:function(){return Headers},Request:function(){return Request},Response:function(){return Response},blobFrom:function(){return P.xB},blobFromSync:function(){return P.SX},default:function(){return fetch},fileFrom:function(){return P.e2},fileFromSync:function(){return P.RA},isRedirect:function(){return isRedirect}});var r=require("node:http");var t=require("node:https");var a=require("node:zlib");var o=require("node:stream");var i=require("node:buffer");function dataUriToBuffer(r){if(!/^data:/i.test(r)){throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")')}r=r.replace(/\r?\n/g,"");const t=r.indexOf(",");if(t===-1||t<=4){throw new TypeError("malformed data: URI")}const n=r.substring(5,t).split(";");let a="";let o=false;const i=n[0]||"text/plain";let l=i;for(let r=1;r<n.length;r++){if(n[r]==="base64"){o=true}else{l+=`;${n[r]}`;if(n[r].indexOf("charset=")===0){a=n[r].substring(8)}}}if(!n[0]&&!a.length){l+=";charset=US-ASCII";a="US-ASCII"}const s=o?"base64":"ascii";const u=unescape(r.substring(t+1));const d=Buffer.from(u,s);d.type=i;d.typeFull=l;d.charset=a;return d}var l=dataUriToBuffer;var s=require("node:util");var u=__nccwpck_require__(876);var d=__nccwpck_require__(648);class FetchBaseError extends Error{constructor(r,t){super(r);Error.captureStackTrace(this,this.constructor);this.type=t}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class FetchError extends FetchBaseError{constructor(r,t,n){super(r,t);if(n){this.code=this.errno=n.code;this.erroredSysCall=n.syscall}}}const c=Symbol.toStringTag;const isURLSearchParameters=r=>typeof r==="object"&&typeof r.append==="function"&&typeof r.delete==="function"&&typeof r.get==="function"&&typeof r.getAll==="function"&&typeof r.has==="function"&&typeof r.set==="function"&&typeof r.sort==="function"&&r[c]==="URLSearchParams";const isBlob=r=>r&&typeof r==="object"&&typeof r.arrayBuffer==="function"&&typeof r.type==="string"&&typeof r.stream==="function"&&typeof r.constructor==="function"&&/^(Blob|File)$/.test(r[c]);const isAbortSignal=r=>typeof r==="object"&&(r[c]==="AbortSignal"||r[c]==="EventTarget");const isDomainOrSubdomain=(r,t)=>{const n=new URL(t).hostname;const a=new URL(r).hostname;return n===a||n.endsWith(`.${a}`)};const isSameProtocol=(r,t)=>{const n=new URL(t).protocol;const a=new URL(r).protocol;return n===a};const m=(0,s.promisify)(o.pipeline);const b=Symbol("Body internals");class Body{constructor(r,{size:t=0}={}){let n=null;if(r===null){r=null}else if(isURLSearchParameters(r)){r=i.Buffer.from(r.toString())}else if(isBlob(r)){}else if(i.Buffer.isBuffer(r)){}else if(s.types.isAnyArrayBuffer(r)){r=i.Buffer.from(r)}else if(ArrayBuffer.isView(r)){r=i.Buffer.from(r.buffer,r.byteOffset,r.byteLength)}else if(r instanceof o){}else if(r instanceof d.Ct){r=(0,d.au)(r);n=r.type.split("=")[1]}else{r=i.Buffer.from(String(r))}let a=r;if(i.Buffer.isBuffer(r)){a=o.Readable.from(r)}else if(isBlob(r)){a=o.Readable.from(r.stream())}this[b]={body:r,stream:a,boundary:n,disturbed:false,error:null};this.size=t;if(r instanceof o){r.on("error",(r=>{const t=r instanceof FetchBaseError?r:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${r.message}`,"system",r);this[b].error=t}))}}get body(){return this[b].stream}get bodyUsed(){return this[b].disturbed}async arrayBuffer(){const{buffer:r,byteOffset:t,byteLength:n}=await consumeBody(this);return r.slice(t,t+n)}async formData(){const r=this.headers.get("content-type");if(r.startsWith("application/x-www-form-urlencoded")){const r=new d.Ct;const t=new URLSearchParams(await this.text());for(const[n,a]of t){r.append(n,a)}return r}const{toFormData:t}=await __nccwpck_require__.e(933).then(__nccwpck_require__.bind(__nccwpck_require__,933));return t(this.body,r)}async blob(){const r=this.headers&&this.headers.get("content-type")||this[b].body&&this[b].body.type||"";const t=await this.arrayBuffer();return new u.Z([t],{type:r})}async json(){const r=await this.text();return JSON.parse(r)}async text(){const r=await consumeBody(this);return(new TextDecoder).decode(r)}buffer(){return consumeBody(this)}}Body.prototype.buffer=(0,s.deprecate)(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer");Object.defineProperties(Body.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true},data:{get:(0,s.deprecate)((()=>{}),"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});async function consumeBody(r){if(r[b].disturbed){throw new TypeError(`body used already for: ${r.url}`)}r[b].disturbed=true;if(r[b].error){throw r[b].error}const{body:t}=r;if(t===null){return i.Buffer.alloc(0)}if(!(t instanceof o)){return i.Buffer.alloc(0)}const n=[];let a=0;try{for await(const o of t){if(r.size>0&&a+o.length>r.size){const n=new FetchError(`content size at ${r.url} over limit: ${r.size}`,"max-size");t.destroy(n);throw n}a+=o.length;n.push(o)}}catch(t){const n=t instanceof FetchBaseError?t:new FetchError(`Invalid response body while trying to fetch ${r.url}: ${t.message}`,"system",t);throw n}if(t.readableEnded===true||t._readableState.ended===true){try{if(n.every((r=>typeof r==="string"))){return i.Buffer.from(n.join(""))}return i.Buffer.concat(n,a)}catch(t){throw new FetchError(`Could not create Buffer from response body for ${r.url}: ${t.message}`,"system",t)}}else{throw new FetchError(`Premature close of server response while trying to fetch ${r.url}`)}}const clone=(r,t)=>{let n;let a;let{body:i}=r[b];if(r.bodyUsed){throw new Error("cannot clone body after it is used")}if(i instanceof o&&typeof i.getBoundary!=="function"){n=new o.PassThrough({highWaterMark:t});a=new o.PassThrough({highWaterMark:t});i.pipe(n);i.pipe(a);r[b].stream=n;i=a}return i};const h=(0,s.deprecate)((r=>r.getBoundary()),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167");const extractContentType=(r,t)=>{if(r===null){return null}if(typeof r==="string"){return"text/plain;charset=UTF-8"}if(isURLSearchParameters(r)){return"application/x-www-form-urlencoded;charset=UTF-8"}if(isBlob(r)){return r.type||null}if(i.Buffer.isBuffer(r)||s.types.isAnyArrayBuffer(r)||ArrayBuffer.isView(r)){return null}if(r instanceof d.Ct){return`multipart/form-data; boundary=${t[b].boundary}`}if(r&&typeof r.getBoundary==="function"){return`multipart/form-data;boundary=${h(r)}`}if(r instanceof o){return null}return"text/plain;charset=UTF-8"};const getTotalBytes=r=>{const{body:t}=r[b];if(t===null){return 0}if(isBlob(t)){return t.size}if(i.Buffer.isBuffer(t)){return t.length}if(t&&typeof t.getLengthSync==="function"){return t.hasKnownLength&&t.hasKnownLength()?t.getLengthSync():null}return null};const writeToStream=async(r,{body:t})=>{if(t===null){r.end()}else{await m(t,r)}};const p=typeof r.validateHeaderName==="function"?r.validateHeaderName:r=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(r)){const t=new TypeError(`Header name must be a valid HTTP token [${r}]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_HTTP_TOKEN"});throw t}};const S=typeof r.validateHeaderValue==="function"?r.validateHeaderValue:(r,t)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(t)){const t=new TypeError(`Invalid character in header content ["${r}"]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_CHAR"});throw t}};class Headers extends URLSearchParams{constructor(r){let t=[];if(r instanceof Headers){const n=r.raw();for(const[r,a]of Object.entries(n)){t.push(...a.map((t=>[r,t])))}}else if(r==null){}else if(typeof r==="object"&&!s.types.isBoxedPrimitive(r)){const n=r[Symbol.iterator];if(n==null){t.push(...Object.entries(r))}else{if(typeof n!=="function"){throw new TypeError("Header pairs must be iterable")}t=[...r].map((r=>{if(typeof r!=="object"||s.types.isBoxedPrimitive(r)){throw new TypeError("Each header pair must be an iterable object")}return[...r]})).map((r=>{if(r.length!==2){throw new TypeError("Each header pair must be a name/value tuple")}return[...r]}))}}else{throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)")}t=t.length>0?t.map((([r,t])=>{p(r);S(r,String(t));return[String(r).toLowerCase(),String(t)]})):undefined;super(t);return new Proxy(this,{get(r,t,n){switch(t){case"append":case"set":return(n,a)=>{p(n);S(n,String(a));return URLSearchParams.prototype[t].call(r,String(n).toLowerCase(),String(a))};case"delete":case"has":case"getAll":return n=>{p(n);return URLSearchParams.prototype[t].call(r,String(n).toLowerCase())};case"keys":return()=>{r.sort();return new Set(URLSearchParams.prototype.keys.call(r)).keys()};default:return Reflect.get(r,t,n)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(r){const t=this.getAll(r);if(t.length===0){return null}let n=t.join(", ");if(/^content-encoding$/i.test(r)){n=n.toLowerCase()}return n}forEach(r,t=undefined){for(const n of this.keys()){Reflect.apply(r,t,[this.get(n),n,this])}}*values(){for(const r of this.keys()){yield this.get(r)}}*entries(){for(const r of this.keys()){yield[r,this.get(r)]}}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce(((r,t)=>{r[t]=this.getAll(t);return r}),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce(((r,t)=>{const n=this.getAll(t);if(t==="host"){r[t]=n[0]}else{r[t]=n.length>1?n:n[0]}return r}),{})}}Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce(((r,t)=>{r[t]={enumerable:true};return r}),{}));function fromRawHeaders(r=[]){return new Headers(r.reduce(((r,t,n,a)=>{if(n%2===0){r.push(a.slice(n,n+2))}return r}),[]).filter((([r,t])=>{try{p(r);S(r,String(t));return true}catch{return false}})))}const y=new Set([301,302,303,307,308]);const isRedirect=r=>y.has(r);const R=Symbol("Response internals");class Response extends Body{constructor(r=null,t={}){super(r,t);const n=t.status!=null?t.status:200;const a=new Headers(t.headers);if(r!==null&&!a.has("Content-Type")){const t=extractContentType(r,this);if(t){a.append("Content-Type",t)}}this[R]={type:"default",url:t.url,status:n,statusText:t.statusText||"",headers:a,counter:t.counter,highWaterMark:t.highWaterMark}}get type(){return this[R].type}get url(){return this[R].url||""}get status(){return this[R].status}get ok(){return this[R].status>=200&&this[R].status<300}get redirected(){return this[R].counter>0}get statusText(){return this[R].statusText}get headers(){return this[R].headers}get highWaterMark(){return this[R].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(r,t=302){if(!isRedirect(t)){throw new RangeError('Failed to execute "redirect" on "response": Invalid status code')}return new Response(null,{headers:{location:new URL(r).toString()},status:t})}static error(){const r=new Response(null,{status:0,statusText:""});r[R].type="error";return r}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(Response.prototype,{type:{enumerable:true},url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}});var g=require("node:url");const getSearch=r=>{if(r.search){return r.search}const t=r.href.length-1;const n=r.hash||(r.href[t]==="#"?"#":"");return r.href[t-n.length]==="?"?"?":""};var _=require("node:net");function stripURLForUseAsAReferrer(r,t=false){if(r==null){return"no-referrer"}r=new URL(r);if(/^(about|blob|data):$/.test(r.protocol)){return"no-referrer"}r.username="";r.password="";r.hash="";if(t){r.pathname="";r.search=""}return r}const C=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]);const w="strict-origin-when-cross-origin";function validateReferrerPolicy(r){if(!C.has(r)){throw new TypeError(`Invalid referrerPolicy: ${r}`)}return r}function isOriginPotentiallyTrustworthy(r){if(/^(http|ws)s:$/.test(r.protocol)){return true}const t=r.host.replace(/(^\[)|(]$)/g,"");const n=(0,_.isIP)(t);if(n===4&&/^127\./.test(t)){return true}if(n===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(t)){return true}if(r.host==="localhost"||r.host.endsWith(".localhost")){return false}if(r.protocol==="file:"){return true}return false}function isUrlPotentiallyTrustworthy(r){if(/^about:(blank|srcdoc)$/.test(r)){return true}if(r.protocol==="data:"){return true}if(/^(blob|filesystem):$/.test(r.protocol)){return true}return isOriginPotentiallyTrustworthy(r)}function determineRequestsReferrer(r,{referrerURLCallback:t,referrerOriginCallback:n}={}){if(r.referrer==="no-referrer"||r.referrerPolicy===""){return null}const a=r.referrerPolicy;if(r.referrer==="about:client"){return"no-referrer"}const o=r.referrer;let i=stripURLForUseAsAReferrer(o);let l=stripURLForUseAsAReferrer(o,true);if(i.toString().length>4096){i=l}if(t){i=t(i)}if(n){l=n(l)}const s=new URL(r.url);switch(a){case"no-referrer":return"no-referrer";case"origin":return l;case"unsafe-url":return i;case"strict-origin":if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return l.toString();case"strict-origin-when-cross-origin":if(i.origin===s.origin){return i}if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return l;case"same-origin":if(i.origin===s.origin){return i}return"no-referrer";case"origin-when-cross-origin":if(i.origin===s.origin){return i}return l;case"no-referrer-when-downgrade":if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return i;default:throw new TypeError(`Invalid referrerPolicy: ${a}`)}}function parseReferrerPolicyFromHeader(r){const t=(r.get("referrer-policy")||"").split(/[,\s]+/);let n="";for(const r of t){if(r&&C.has(r)){n=r}}return n}const W=Symbol("Request internals");const isRequest=r=>typeof r==="object"&&typeof r[W]==="object";const B=(0,s.deprecate)((()=>{}),".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class Request extends Body{constructor(r,t={}){let n;if(isRequest(r)){n=new URL(r.url)}else{n=new URL(r);r={}}if(n.username!==""||n.password!==""){throw new TypeError(`${n} is an url with embedded credentials.`)}let a=t.method||r.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(a)){a=a.toUpperCase()}if(!isRequest(t)&&"data"in t){B()}if((t.body!=null||isRequest(r)&&r.body!==null)&&(a==="GET"||a==="HEAD")){throw new TypeError("Request with GET/HEAD method cannot have body")}const o=t.body?t.body:isRequest(r)&&r.body!==null?clone(r):null;super(o,{size:t.size||r.size||0});const i=new Headers(t.headers||r.headers||{});if(o!==null&&!i.has("Content-Type")){const r=extractContentType(o,this);if(r){i.set("Content-Type",r)}}let l=isRequest(r)?r.signal:null;if("signal"in t){l=t.signal}if(l!=null&&!isAbortSignal(l)){throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget")}let s=t.referrer==null?r.referrer:t.referrer;if(s===""){s="no-referrer"}else if(s){const r=new URL(s);s=/^about:(\/\/)?client$/.test(r)?"client":r}else{s=undefined}this[W]={method:a,redirect:t.redirect||r.redirect||"follow",headers:i,parsedURL:n,signal:l,referrer:s};this.follow=t.follow===undefined?r.follow===undefined?20:r.follow:t.follow;this.compress=t.compress===undefined?r.compress===undefined?true:r.compress:t.compress;this.counter=t.counter||r.counter||0;this.agent=t.agent||r.agent;this.highWaterMark=t.highWaterMark||r.highWaterMark||16384;this.insecureHTTPParser=t.insecureHTTPParser||r.insecureHTTPParser||false;this.referrerPolicy=t.referrerPolicy||r.referrerPolicy||""}get method(){return this[W].method}get url(){return(0,g.format)(this[W].parsedURL)}get headers(){return this[W].headers}get redirect(){return this[W].redirect}get signal(){return this[W].signal}get referrer(){if(this[W].referrer==="no-referrer"){return""}if(this[W].referrer==="client"){return"about:client"}if(this[W].referrer){return this[W].referrer.toString()}return undefined}get referrerPolicy(){return this[W].referrerPolicy}set referrerPolicy(r){this[W].referrerPolicy=validateReferrerPolicy(r)}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties(Request.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true},referrer:{enumerable:true},referrerPolicy:{enumerable:true}});const getNodeRequestOptions=r=>{const{parsedURL:t}=r[W];const n=new Headers(r[W].headers);if(!n.has("Accept")){n.set("Accept","*/*")}let a=null;if(r.body===null&&/^(post|put)$/i.test(r.method)){a="0"}if(r.body!==null){const t=getTotalBytes(r);if(typeof t==="number"&&!Number.isNaN(t)){a=String(t)}}if(a){n.set("Content-Length",a)}if(r.referrerPolicy===""){r.referrerPolicy=w}if(r.referrer&&r.referrer!=="no-referrer"){r[W].referrer=determineRequestsReferrer(r)}else{r[W].referrer="no-referrer"}if(r[W].referrer instanceof URL){n.set("Referer",r.referrer)}if(!n.has("User-Agent")){n.set("User-Agent","node-fetch")}if(r.compress&&!n.has("Accept-Encoding")){n.set("Accept-Encoding","gzip, deflate, br")}let{agent:o}=r;if(typeof o==="function"){o=o(t)}if(!n.has("Connection")&&!o){n.set("Connection","close")}const i=getSearch(t);const l={path:t.pathname+i,method:r.method,headers:n[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:r.insecureHTTPParser,agent:o};return{parsedURL:t,options:l}};class AbortError extends FetchBaseError{constructor(r,t="aborted"){super(r,t)}}var P=__nccwpck_require__(825);const T=new Set(["data:","http:","https:"]);async function fetch(n,i){return new Promise(((s,u)=>{const d=new Request(n,i);const{parsedURL:c,options:m}=getNodeRequestOptions(d);if(!T.has(c.protocol)){throw new TypeError(`node-fetch cannot load ${n}. URL scheme "${c.protocol.replace(/:$/,"")}" is not supported.`)}if(c.protocol==="data:"){const r=l(d.url);const t=new Response(r,{headers:{"Content-Type":r.typeFull}});s(t);return}const b=(c.protocol==="https:"?t:r).request;const{signal:h}=d;let p=null;const abort=()=>{const r=new AbortError("The operation was aborted.");u(r);if(d.body&&d.body instanceof o.Readable){d.body.destroy(r)}if(!p||!p.body){return}p.body.emit("error",r)};if(h&&h.aborted){abort();return}const abortAndFinalize=()=>{abort();finalize()};const S=b(c.toString(),m);if(h){h.addEventListener("abort",abortAndFinalize)}const finalize=()=>{S.abort();if(h){h.removeEventListener("abort",abortAndFinalize)}};S.on("error",(r=>{u(new FetchError(`request to ${d.url} failed, reason: ${r.message}`,"system",r));finalize()}));fixResponseChunkedTransferBadEnding(S,(r=>{if(p&&p.body){p.body.destroy(r)}}));if(process.version<"v14"){S.on("socket",(r=>{let t;r.prependListener("end",(()=>{t=r._eventsCount}));r.prependListener("close",(n=>{if(p&&t<r._eventsCount&&!n){const r=new Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE";p.body.emit("error",r)}}))}))}S.on("response",(r=>{S.setTimeout(0);const t=fromRawHeaders(r.rawHeaders);if(isRedirect(r.statusCode)){const n=t.get("Location");let a=null;try{a=n===null?null:new URL(n,d.url)}catch{if(d.redirect!=="manual"){u(new FetchError(`uri requested responds with an invalid redirect URL: ${n}`,"invalid-redirect"));finalize();return}}switch(d.redirect){case"error":u(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${d.url}`,"no-redirect"));finalize();return;case"manual":break;case"follow":{if(a===null){break}if(d.counter>=d.follow){u(new FetchError(`maximum redirect reached at: ${d.url}`,"max-redirect"));finalize();return}const n={headers:new Headers(d.headers),follow:d.follow,counter:d.counter+1,agent:d.agent,compress:d.compress,method:d.method,body:clone(d),signal:d.signal,size:d.size,referrer:d.referrer,referrerPolicy:d.referrerPolicy};if(!isDomainOrSubdomain(d.url,a)||!isSameProtocol(d.url,a)){for(const r of["authorization","www-authenticate","cookie","cookie2"]){n.headers.delete(r)}}if(r.statusCode!==303&&d.body&&i.body instanceof o.Readable){u(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect"));finalize();return}if(r.statusCode===303||(r.statusCode===301||r.statusCode===302)&&d.method==="POST"){n.method="GET";n.body=undefined;n.headers.delete("content-length")}const l=parseReferrerPolicyFromHeader(t);if(l){n.referrerPolicy=l}s(fetch(new Request(a,n)));finalize();return}default:return u(new TypeError(`Redirect option '${d.redirect}' is not a valid value of RequestRedirect`))}}if(h){r.once("end",(()=>{h.removeEventListener("abort",abortAndFinalize)}))}let n=(0,o.pipeline)(r,new o.PassThrough,(r=>{if(r){u(r)}}));if(process.version<"v12.10"){r.on("aborted",abortAndFinalize)}const l={url:d.url,status:r.statusCode,statusText:r.statusMessage,headers:t,size:d.size,counter:d.counter,highWaterMark:d.highWaterMark};const c=t.get("Content-Encoding");if(!d.compress||d.method==="HEAD"||c===null||r.statusCode===204||r.statusCode===304){p=new Response(n,l);s(p);return}const m={flush:a.Z_SYNC_FLUSH,finishFlush:a.Z_SYNC_FLUSH};if(c==="gzip"||c==="x-gzip"){n=(0,o.pipeline)(n,a.createGunzip(m),(r=>{if(r){u(r)}}));p=new Response(n,l);s(p);return}if(c==="deflate"||c==="x-deflate"){const t=(0,o.pipeline)(r,new o.PassThrough,(r=>{if(r){u(r)}}));t.once("data",(r=>{if((r[0]&15)===8){n=(0,o.pipeline)(n,a.createInflate(),(r=>{if(r){u(r)}}))}else{n=(0,o.pipeline)(n,a.createInflateRaw(),(r=>{if(r){u(r)}}))}p=new Response(n,l);s(p)}));t.once("end",(()=>{if(!p){p=new Response(n,l);s(p)}}));return}if(c==="br"){n=(0,o.pipeline)(n,a.createBrotliDecompress(),(r=>{if(r){u(r)}}));p=new Response(n,l);s(p);return}p=new Response(n,l);s(p)}));writeToStream(S,d).catch(u)}))}function fixResponseChunkedTransferBadEnding(r,t){const n=i.Buffer.from("0\r\n\r\n");let a=false;let o=false;let l;r.on("response",(r=>{const{headers:t}=r;a=t["transfer-encoding"]==="chunked"&&!t["content-length"]}));r.on("socket",(s=>{const onSocketClose=()=>{if(a&&!o){const r=new Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE";t(r)}};const onData=r=>{o=i.Buffer.compare(r.slice(-5),n)===0;if(!o&&l){o=i.Buffer.compare(l.slice(-3),n.slice(0,3))===0&&i.Buffer.compare(r.slice(-2),n.slice(3))===0}l=r};s.prependListener("close",onSocketClose);s.on("data",onData);r.on("close",(()=>{s.removeListener("close",onSocketClose);s.removeListener("data",onData)}))}))}}();module.exports=n})();